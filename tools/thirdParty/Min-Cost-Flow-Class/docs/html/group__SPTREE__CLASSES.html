<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Classes in SPTree.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__SPTREE__CLASSES.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Classes in SPTree.h<div class="ingroups"><a class="el" href="group__SPTREE__MACROS.html">Compile-time switches in SPTree.h</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html">SPTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSPTree.html" title="The SPTree class derives from the abstract base class MCFClass, thus sharing its (standard) interface...">SPTree</a> class derives from the abstract base class <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>, thus sharing its (standard) interface, and implements Shortest Path Tree algorithms for solving "uncapacitated" (Linear) Min Cost Flow problems with one source node.  <a href="classSPTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaeb17eda40b01161160b996e7e0f7f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#gaaeb17eda40b01161160b996e7e0f7f23">SPTree</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> nmx=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> mmx=0, bool Drctd=true)</td></tr>
<tr class="memdesc:gaaeb17eda40b01161160b996e7e0f7f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="group__SPTREE__CLASSES.html#gaaeb17eda40b01161160b996e7e0f7f23">More...</a><br /></td></tr>
<tr class="separator:gaaeb17eda40b01161160b996e7e0f7f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbfa5c036f9ea67e35005ec77b82214a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#gafbfa5c036f9ea67e35005ec77b82214a">LoadNet</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> nmx=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> mmx=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> pn=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> pm=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> pU=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a> pC=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> pDfct=0, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> pSn=0, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> pEn=0) override</td></tr>
<tr class="memdesc:gafbfa5c036f9ea67e35005ec77b82214a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs a new network, as in <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">MCFClass::LoadNet()</a>.  <a href="group__SPTREE__CLASSES.html#gafbfa5c036f9ea67e35005ec77b82214a">More...</a><br /></td></tr>
<tr class="separator:gafbfa5c036f9ea67e35005ec77b82214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eb8e4b396fb6d82d56dcb9b7fbe871b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#ga2eb8e4b396fb6d82d56dcb9b7fbe871b">MCFGetPi</a> (void) override</td></tr>
<tr class="memdesc:ga2eb8e4b396fb6d82d56dcb9b7fbe871b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same meaning as <a class="el" href="group__MCFCLASS__CLASSES.html#ga8c573c04800332c86ea31aeb80bbd7b1" title="Writes the optimal node potentials in the vector P[].">MCFClass::MCFGetPi()</a>.  <a href="group__SPTREE__CLASSES.html#ga2eb8e4b396fb6d82d56dcb9b7fbe871b">More...</a><br /></td></tr>
<tr class="separator:ga2eb8e4b396fb6d82d56dcb9b7fbe871b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55b9b095d557852a91b68c973236518a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MCFCLASS__CLASSES.html#gaf5ee7b3099b0bc780a6a4b43629488fa">SPTree::FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#ga55b9b095d557852a91b68c973236518a">MCFGetFO</a> (void) override</td></tr>
<tr class="memdesc:ga55b9b095d557852a91b68c973236518a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same meaning as <a class="el" href="group__MCFCLASS__CLASSES.html#ga109d7c021feda837d8ca5051fc24b6ea" title="Return the objective function value of the primal solution currently returned by MCFGetX().">MCFClass::MCFGetFO()</a>.  <a href="group__SPTREE__CLASSES.html#ga55b9b095d557852a91b68c973236518a">More...</a><br /></td></tr>
<tr class="separator:ga55b9b095d557852a91b68c973236518a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e377a946e5a08dba5172117eaf68a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#ga76e377a946e5a08dba5172117eaf68a8">ShortestPathTree</a> (void)</td></tr>
<tr class="memdesc:ga76e377a946e5a08dba5172117eaf68a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver of the Shortest Path Tree Problem from the current Origin.  <a href="group__SPTREE__CLASSES.html#ga76e377a946e5a08dba5172117eaf68a8">More...</a><br /></td></tr>
<tr class="separator:ga76e377a946e5a08dba5172117eaf68a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90071ff5bdcd7e73fe156180fe7ffcee"><td class="memItemLeft" align="right" valign="top"><a id="ga90071ff5bdcd7e73fe156180fe7ffcee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#ga90071ff5bdcd7e73fe156180fe7ffcee">SetOrigin</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> NewOrg)</td></tr>
<tr class="memdesc:ga90071ff5bdcd7e73fe156180fe7ffcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Origin from which Shortest Paths are computed. <br /></td></tr>
<tr class="separator:ga90071ff5bdcd7e73fe156180fe7ffcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fad8461dbf04f0981f698a4d1b9fbd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#ga1fad8461dbf04f0981f698a4d1b9fbd9">SetDest</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> NewDst)</td></tr>
<tr class="memdesc:ga1fad8461dbf04f0981f698a4d1b9fbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Destination node of Shotest Paths.  <a href="group__SPTREE__CLASSES.html#ga1fad8461dbf04f0981f698a4d1b9fbd9">More...</a><br /></td></tr>
<tr class="separator:ga1fad8461dbf04f0981f698a4d1b9fbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe1dba1878b1ac62056bbba3368e23f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#gafe1dba1878b1ac62056bbba3368e23f6">MCFGetX</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> ND, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> DB, <a class="el" href="group__MCFCLASS__CLASSES.html#ga9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> F, <a class="el" href="group__MCFCLASS__CLASSES.html#gace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="memdesc:gafe1dba1878b1ac62056bbba3368e23f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like SPTree::MCFGetX( FRow , Index_Set , cIndex , Index ), except that the primal solution that is returned is relative only to the subset of destinations whose names are contained in the first ND entries of the vector DB.  <a href="group__SPTREE__CLASSES.html#gafe1dba1878b1ac62056bbba3368e23f6">More...</a><br /></td></tr>
<tr class="separator:gafe1dba1878b1ac62056bbba3368e23f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga412b2a0ccb6e2faacb7c2e5081d4e016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MCFCLASS__CLASSES.html#gaf5ee7b3099b0bc780a6a4b43629488fa">SPTree::FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#ga412b2a0ccb6e2faacb7c2e5081d4e016">MCFGetFO</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> ND, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> DB)</td></tr>
<tr class="memdesc:ga412b2a0ccb6e2faacb7c2e5081d4e016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="group__SPTREE__CLASSES.html#ga55b9b095d557852a91b68c973236518a" title="Same meaning as MCFClass::MCFGetFO().">SPTree::MCFGetFO( void )</a>, except that the cost that is returned is that of the primal solution relative only to the subset of destinations whose names are contained in the first ND entries of the vector DB.  <a href="group__SPTREE__CLASSES.html#ga412b2a0ccb6e2faacb7c2e5081d4e016">More...</a><br /></td></tr>
<tr class="separator:ga412b2a0ccb6e2faacb7c2e5081d4e016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451041eba0632676692f2de798bea4d7"><td class="memItemLeft" align="right" valign="top"><a id="ga451041eba0632676692f2de798bea4d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#ga451041eba0632676692f2de798bea4d7">Reached</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> i)</td></tr>
<tr class="memdesc:ga451041eba0632676692f2de798bea4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a shortest path from Origin to i have already been computed; this can be used when LABEL_SETTING == 1 to determine if a shortest from Origin to i have been obtained as a by-product of the calculation of the shortest path between Origin and some other Dest. <br /></td></tr>
<tr class="separator:ga451041eba0632676692f2de798bea4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95a85d44e57ab53fe2b565355f6c054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#gaf95a85d44e57ab53fe2b565355f6c054">Predecessors</a> (void)</td></tr>
<tr class="memdesc:gaf95a85d44e57ab53fe2b565355f6c054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cIndex* vector p[] such that p[ i ] is the predecessor of node i in the shortest path tree.  <a href="group__SPTREE__CLASSES.html#gaf95a85d44e57ab53fe2b565355f6c054">More...</a><br /></td></tr>
<tr class="separator:gaf95a85d44e57ab53fe2b565355f6c054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccf9d3766b10881f0b92387e3a9f914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#gaaccf9d3766b10881f0b92387e3a9f914">ArcPredecessors</a> (void)</td></tr>
<tr class="memdesc:gaaccf9d3766b10881f0b92387e3a9f914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cIndex* vector a[] such that a[ i ] is the index of the arc ( p[ i ] , i ), being p[] the vector returned by the above method, and with the same structure.  <a href="group__SPTREE__CLASSES.html#gaaccf9d3766b10881f0b92387e3a9f914">More...</a><br /></td></tr>
<tr class="separator:gaaccf9d3766b10881f0b92387e3a9f914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae75a8a94d994b6a98934b241c969bdc6"><td class="memItemLeft" align="right" valign="top"><a id="gae75a8a94d994b6a98934b241c969bdc6"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#gae75a8a94d994b6a98934b241c969bdc6">Orig</a> (void)</td></tr>
<tr class="memdesc:gae75a8a94d994b6a98934b241c969bdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the root of the SPT problem. <br /></td></tr>
<tr class="separator:gae75a8a94d994b6a98934b241c969bdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfad352a13e6be066a344f09b34148da"><td class="memItemLeft" align="right" valign="top"><a id="gadfad352a13e6be066a344f09b34148da"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#gadfad352a13e6be066a344f09b34148da">DestN</a> (void)</td></tr>
<tr class="memdesc:gadfad352a13e6be066a344f09b34148da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of destination nodes in the SPT problem. <br /></td></tr>
<tr class="separator:gadfad352a13e6be066a344f09b34148da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c4139e9f19c46099f798ec496faca2c"><td class="memItemLeft" align="right" valign="top"><a id="ga0c4139e9f19c46099f798ec496faca2c"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#ga0c4139e9f19c46099f798ec496faca2c">Dests</a> (void)</td></tr>
<tr class="memdesc:ga0c4139e9f19c46099f798ec496faca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="group__SPTREE__CLASSES.html#gadfad352a13e6be066a344f09b34148da" title="Return the number of destination nodes in the SPT problem.">DestN()</a>-vector containig the names of destination nodes in the SPT problem; the names are in increasing order and INF-terminated. <br /></td></tr>
<tr class="separator:ga0c4139e9f19c46099f798ec496faca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae131faa3f8901f33f24617a4e61f601b"><td class="memItemLeft" align="right" valign="top"><a id="gae131faa3f8901f33f24617a4e61f601b"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#gae131faa3f8901f33f24617a4e61f601b">LenFS</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> i)</td></tr>
<tr class="memdesc:gae131faa3f8901f33f24617a4e61f601b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the Forward Star of node i. <br /></td></tr>
<tr class="separator:gae131faa3f8901f33f24617a4e61f601b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd79f2ffc8ffb4e444fa60a6bb4ebbe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPTREE__CLASSES.html#gafd79f2ffc8ffb4e444fa60a6bb4ebbe1">ReadFS</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> i, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> h)</td></tr>
<tr class="memdesc:gafd79f2ffc8ffb4e444fa60a6bb4ebbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the h-th arc in FS( i ) for h = 0, ...  <a href="group__SPTREE__CLASSES.html#gafd79f2ffc8ffb4e444fa60a6bb4ebbe1">More...</a><br /></td></tr>
<tr class="separator:gafd79f2ffc8ffb4e444fa60a6bb4ebbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaeb17eda40b01161160b996e7e0f7f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeb17eda40b01161160b996e7e0f7f23">&#9670;&nbsp;</a></span>SPTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPTree.html">SPTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>mmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Drctd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the class. </p>
<p>For the meaning of nmx and mmx see MCFClass::MCFClass().</p>
<p>The parameter &lsquo;Drctd&rsquo; tells if the given graph has really to be understood as directed (default), i.e., if the i-th arc is Sn[ i ] --&gt; En[ i ], or undirected, i.e., the i-th arc is Sn[ i ] &lt;--&gt; En[ i ]. Undirected graphs are internally implemented by doubling each arc, but this is completely hidden by the interface. </p>

</div>
</div>
<a id="gafbfa5c036f9ea67e35005ec77b82214a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbfa5c036f9ea67e35005ec77b82214a">&#9670;&nbsp;</a></span>LoadNet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoadNet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>mmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>pn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>pm</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>pU</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>pC</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>pDfct</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>pSn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>pEn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inputs a new network, as in <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">MCFClass::LoadNet()</a>. </p>
<p>Arcs with pC[ i ] == Inf&lt;CNumber&gt;() do not "exist". If DYNMC_MCF_SPT &gt; 0, these arcs are "closed".</p>
<p>If DYNMC_MCF_SPT == 0 but SAME_GRPH_SPT &gt; 0, these arcs are dealt with explicitly, and can be put back into the formulation by simply changing their cost. Note that, however, this is less efficient than eliminating them explicitly from the problem.</p>
<p>If DYNMC_MCF_SPT == 0 and SAME_GRPH_SPT == 0, these arcs are just removed from the formulation. However, they have some sort of a "special status" (after all, if the user wants to remove them completely he/she can just change the data), in that they are still counted into the number of arcs of the graph and they will always have 0 flow and Inf&lt;CNumber&gt;() reduced cost as "closed" or "deleted" arcs. </p>

<p>Implements <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c">MCFClass</a>.</p>

</div>
</div>
<a id="ga2eb8e4b396fb6d82d56dcb9b7fbe871b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eb8e4b396fb6d82d56dcb9b7fbe871b">&#9670;&nbsp;</a></span>MCFGetPi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a> MCFGetPi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same meaning as <a class="el" href="group__MCFCLASS__CLASSES.html#ga8c573c04800332c86ea31aeb80bbd7b1" title="Writes the optimal node potentials in the vector P[].">MCFClass::MCFGetPi()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Some of the potentials may be + Inf&lt;CNumber&gt;(): this means that</dd></dl>
<ul>
<li>the node is <em>not</em> a destination and it cannot be reached from the Origin (however, this does <em>not</em> mean that the problem is unfeasible);</li>
<li>if LABEL_SETTING == 1, the node is <em>not</em> a destination and it has not been reached during the algorithm. </li>
</ul>

</div>
</div>
<a id="ga55b9b095d557852a91b68c973236518a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55b9b095d557852a91b68c973236518a">&#9670;&nbsp;</a></span>MCFGetFO() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MCFCLASS__CLASSES.html#gaf5ee7b3099b0bc780a6a4b43629488fa">SPTree::FONumber</a> MCFGetFO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same meaning as <a class="el" href="group__MCFCLASS__CLASSES.html#ga109d7c021feda837d8ca5051fc24b6ea" title="Return the objective function value of the primal solution currently returned by MCFGetX().">MCFClass::MCFGetFO()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>if not all the specified destinations can be reached from the Origin, returns Inf&lt;FONumber&gt;(). </dd></dl>

<p>Implements <a class="el" href="group__MCFCLASS__CLASSES.html#ga109d7c021feda837d8ca5051fc24b6ea">MCFClass</a>.</p>

</div>
</div>
<a id="ga76e377a946e5a08dba5172117eaf68a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76e377a946e5a08dba5172117eaf68a8">&#9670;&nbsp;</a></span>ShortestPathTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShortestPathTree </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solver of the Shortest Path Tree Problem from the current Origin. </p>
<p>(specified in the constructor or by <a class="el" href="group__SPTREE__CLASSES.html#ga90071ff5bdcd7e73fe156180fe7ffcee" title="Changes the Origin from which Shortest Paths are computed.">SetOrigin()</a>, see below)</p>
<p>If LABEL_SETTING == 0, or if no Destination is speficied (Dst == Inf&lt;Index&gt;() in <a class="el" href="group__SPTREE__CLASSES.html#ga1fad8461dbf04f0981f698a4d1b9fbd9" title="Changes the Destination node of Shotest Paths.">SetDest()</a> [see below]), the whole Shortest Path Tree (at least, the SPT of the component of the graph connected with Origin) is computed, otherwise the code stops as soon as the shortest path between Origin and Dest is computed.</p>
<p>Note that methods such as MCFGetX(), MCFGetRC() and <a class="el" href="group__SPTREE__CLASSES.html#ga55b9b095d557852a91b68c973236518a" title="Same meaning as MCFClass::MCFGetFO().">MCFGetFO()</a> may need some complicate calculations in order to put the solution of the Shortest Path in the correct format; since these calculations change some of the internal data structures, it is not permitted to call again <a class="el" href="group__SPTREE__CLASSES.html#ga76e377a946e5a08dba5172117eaf68a8" title="Solver of the Shortest Path Tree Problem from the current Origin.">ShortestPathTree()</a> after that any of these methods have been called. </p>

</div>
</div>
<a id="ga1fad8461dbf04f0981f698a4d1b9fbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fad8461dbf04f0981f698a4d1b9fbd9">&#9670;&nbsp;</a></span>SetDest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetDest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>NewDst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the Destination node of Shotest Paths. </p>
<p>If LABEL_SETTING == 0, it has no influence since label correcting methods cannot stop before the whole SPT has been computed. Conversely, label setting algorithms can solve Origin-Dest Shortest Path Problems; therefore, it is possible to obtain shortest paths between Origin and a subset of the nodes, by calling <a class="el" href="group__SPTREE__CLASSES.html#ga76e377a946e5a08dba5172117eaf68a8" title="Solver of the Shortest Path Tree Problem from the current Origin.">ShortestPathTree()</a> with one of the destinations, and controlling upon completion that all the desidered nodes have been visited (see <a class="el" href="group__SPTREE__CLASSES.html#ga451041eba0632676692f2de798bea4d7" title="Return true if a shortest path from Origin to i have already been computed; this can be used when LAB...">Reached()</a> below). If this is not the case, <a class="el" href="group__SPTREE__CLASSES.html#ga76e377a946e5a08dba5172117eaf68a8" title="Solver of the Shortest Path Tree Problem from the current Origin.">ShortestPathTree()</a> can be invoked again with one of the unreached nodes, until they are all visited.</p>
<p>If no Dest is given, or if Dest is set to Inf&lt;Index&gt;(), the whole Shortest Path Tree (at least, the SPT of the component of the graph connected with Origin) is computed. </p>

<p class="reference">References <a class="el" href="group__MCFCLASS__CLASSES.html#gga15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1">MCFClass::kUnSolved</a>, and <a class="el" href="group__MCFCLASS__MACROS.html#ga74cc96ffa32533b7eff040b5ffee5e06">USENAME0</a>.</p>

</div>
</div>
<a id="gafe1dba1878b1ac62056bbba3368e23f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe1dba1878b1ac62056bbba3368e23f6">&#9670;&nbsp;</a></span>MCFGetX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFGetX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>ND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>DB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like SPTree::MCFGetX( FRow , Index_Set , cIndex , Index ), except that the primal solution that is returned is relative only to the subset of destinations whose names are contained in the first ND entries of the vector DB. </p>
<p>Note: node names in ND must be in 1 ... n irrespective of USENAME0. </p>

</div>
</div>
<a id="ga412b2a0ccb6e2faacb7c2e5081d4e016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga412b2a0ccb6e2faacb7c2e5081d4e016">&#9670;&nbsp;</a></span>MCFGetFO() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MCFCLASS__CLASSES.html#gaf5ee7b3099b0bc780a6a4b43629488fa">SPTree::FONumber</a> MCFGetFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>ND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>DB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="group__SPTREE__CLASSES.html#ga55b9b095d557852a91b68c973236518a" title="Same meaning as MCFClass::MCFGetFO().">SPTree::MCFGetFO( void )</a>, except that the cost that is returned is that of the primal solution relative only to the subset of destinations whose names are contained in the first ND entries of the vector DB. </p>
<p>Note: node names in ND must be in 1 ... n irrespective of USENAME0. </p>

</div>
</div>
<a id="gaf95a85d44e57ab53fe2b565355f6c054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf95a85d44e57ab53fe2b565355f6c054">&#9670;&nbsp;</a></span>Predecessors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">MCFClass::cIndex_Set</a> Predecessors </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a cIndex* vector p[] such that p[ i ] is the predecessor of node i in the shortest path tree. </p>
<p>If a node i has no predecessor, i.e., i == Origin, i does not belong to the connected component of the origin or the computation have been stopped before reaching i, then p[ i ] == 0.</p>
<dl class="section note"><dt>Note</dt><dd>if the name "0" is used for nodes, (USENAME0 == 1) then node names are internally "translated" of +1 to avoid it being used - the the names reported in this vector will follow the same rule.</dd></dl>
<p>For this reason, the first entry of p (*p) is not significative. </p>

</div>
</div>
<a id="gaaccf9d3766b10881f0b92387e3a9f914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaccf9d3766b10881f0b92387e3a9f914">&#9670;&nbsp;</a></span>ArcPredecessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> ArcPredecessors </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a cIndex* vector a[] such that a[ i ] is the index of the arc ( p[ i ] , i ), being p[] the vector returned by the above method, and with the same structure. </p>
<p>If p[ i ] == 0, then a[ i ] is not significative: for the Origin (that has p[ Origin ] == 0), however, it is guaranteed that a[ Origin ] == Inf&lt;Index&gt;(). </p>

</div>
</div>
<a id="gafd79f2ffc8ffb4e444fa60a6bb4ebbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd79f2ffc8ffb4e444fa60a6bb4ebbe1">&#9670;&nbsp;</a></span>ReadFS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">MCFClass::Index</a> ReadFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the h-th arc in FS( i ) for h = 0, ... </p>
<p>, LenFS( i ) - 1. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
