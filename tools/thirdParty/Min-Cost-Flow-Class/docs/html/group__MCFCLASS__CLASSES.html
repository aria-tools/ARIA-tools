<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Classes in MCFClass.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__MCFCLASS__CLASSES.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enumval-members">Enumerator</a>  </div>
  <div class="headertitle">
<div class="title">Classes in MCFClass.h<div class="ingroups"><a class="el" href="group__MCFCLASS__MACROS.html">Compile-time switches in MCFClass.h</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html">MCFClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract base class defines a standard interface for (linear or convex quadartic separable) Min Cost Flow (MCF) problem solvers.  <a href="classMCFClass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass_1_1MCFState.html">MCFClass::MCFState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for representing the internal state of the MCF algorithm.  <a href="classMCFClass_1_1MCFState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass_1_1MCFException.html">MCFClass::MCFException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small class for exceptions.  <a href="classMCFClass_1_1MCFException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Public types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb308d5c56e12a298bfc0928089348b59"></a>The <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> defines four main public types:</p>
<ul>
<li>Index, the type of arc and node indices;</li>
<li>FNumber, the type of flow variables, arc capacities, and node deficits;</li>
<li>CNumber, the type of flow costs, node potentials, and arc reduced costs;</li>
<li>FONumber, the type of objective function value.</li>
</ul>
<p>By re-defining the types in this section, most MCFSolver should be made to work with any reasonable choice of data type (= one that is capable of properly representing the data of the instances to be solved). This may be relevant due to an important property of MCF problems: <em>if all arc capacities and node deficits are integer, then there exists an integral optimal primal solution</em>, and <em>if all arc costs are integer, then there exists an integral optimal dual solution</em>. Even more importantly, <em>many solution algorithms will in fact produce an integral primal/dual solution for free</em>, because <em>every primal/dual solution they generate during the solution process is naturally integral</em>. Therefore, one can use integer data types to represent everything connected with flows and/or costs if the corresponding data is integer in all instances one needs to solve. This directly translates in significant memory savings and/or speed improvements.</p>
<p>It is the user's responsibility to ensure that these types are set to reasonable values*. So, the experienced user may want to experiment with setting this data properly if memory footprint and/or speed is a primary concern. Note, however, that <em>not all solution algorithms will happily accept integer data</em>; one example are Interior-Point approaches, which require both flow and cost variables to be continuous (float). So, the viability of setting integer data (as well as its impact on performances) is strictly related to the specific kind of algorithm used. Since these types are common to all derived classes, they have to be set taking into account the needs of all the solvers that are going to be used, and adapting to the "worst case"; of course, FNumber == CNumber == double is going to always be an acceptable "worst case" setting. <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> may in a future be defined as a template class, with these as template parameters, but this is currently deemed overkill and avoided.</p>
<p>Finally, note that the above integrality property only holds for <em>linear</em> MCF problems. If any arc has a nonzero quadratic cost coefficient, optimal flows and potentials may be fractional even if all the data of the problem (comprised quadratic cost coefficients) is integer. Hence, for <em>quadratic</em> MCF solvers, a setting like FNumber == CNumber == double is actually mandatory*, for any reasonable algorithm will typically misbehave otherwise. </p>
</td></tr>
<tr class="memitem:gaf6e60cb841150361862d6b895c523e0a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gaf6e60cb841150361862d6b895c523e0a">MCFParam</a> { <br />
&#160;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#ggaf6e60cb841150361862d6b895c523e0aab35d3e473676b56fa123d6df3d855aa0">kMaxTime</a> = 0, 
<a class="el" href="group__MCFCLASS__CLASSES.html#ggaf6e60cb841150361862d6b895c523e0aa50d3edcd55bc1dd84d4e1719430f9d20">kMaxIter</a>, 
<a class="el" href="group__MCFCLASS__CLASSES.html#ggaf6e60cb841150361862d6b895c523e0aa753a94f6a06a5579eb0855479dfbb6b1">kEpsFlw</a>, 
<a class="el" href="group__MCFCLASS__CLASSES.html#ggaf6e60cb841150361862d6b895c523e0aa409d9ed5655d184667a5e486e5110c6e">kEpsDfct</a>, 
<br />
&#160;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#ggaf6e60cb841150361862d6b895c523e0aaf263085cb23be60527c92896891cd12c">kEpsCst</a>, 
<a class="el" href="group__MCFCLASS__CLASSES.html#ggaf6e60cb841150361862d6b895c523e0aa7efdbe01bec821f08a391f9542086475">kReopt</a>, 
<a class="el" href="group__MCFCLASS__CLASSES.html#ggaf6e60cb841150361862d6b895c523e0aa99ac8339170db67bf9af4a60362ef7e1">kLastParam</a>
<br />
 }</td></tr>
<tr class="memdesc:gaf6e60cb841150361862d6b895c523e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible parameters of the MCF solver, to be used with the methods SetPar() and GetPar().  <a href="group__MCFCLASS__CLASSES.html#gaf6e60cb841150361862d6b895c523e0a">More...</a><br /></td></tr>
<tr class="separator:gaf6e60cb841150361862d6b895c523e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ef269c5dd98eea5274eb03a3feb5fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga15ef269c5dd98eea5274eb03a3feb5fb">MCFStatus</a> { <br />
&#160;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gga15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1">kUnSolved</a> = -1, 
<a class="el" href="group__MCFCLASS__CLASSES.html#gga15ef269c5dd98eea5274eb03a3feb5fba42e6b26684acf67af002df88a9cf997c">kOK</a> = 0, 
<a class="el" href="group__MCFCLASS__CLASSES.html#gga15ef269c5dd98eea5274eb03a3feb5fba142714524ffdfe9cfebaa1033fd1a18f">kStopped</a>, 
<a class="el" href="group__MCFCLASS__CLASSES.html#gga15ef269c5dd98eea5274eb03a3feb5fba7db95dc60f32bc33a35f748f639cc6d0">kUnfeasible</a>, 
<br />
&#160;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gga15ef269c5dd98eea5274eb03a3feb5fba4b9de95ee3087851acd98262e09f0be8">kUnbounded</a>, 
<a class="el" href="group__MCFCLASS__CLASSES.html#gga15ef269c5dd98eea5274eb03a3feb5fbaacb2c04376333850bff6fb1065c0c171">kError</a>
<br />
 }</td></tr>
<tr class="memdesc:ga15ef269c5dd98eea5274eb03a3feb5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible status of the MCF solver.  <a href="group__MCFCLASS__CLASSES.html#ga15ef269c5dd98eea5274eb03a3feb5fb">More...</a><br /></td></tr>
<tr class="separator:ga15ef269c5dd98eea5274eb03a3feb5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b7f4459be059eae1a7d83a8e190c28"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gad7b7f4459be059eae1a7d83a8e190c28">MCFAnswer</a> { <a class="el" href="group__MCFCLASS__CLASSES.html#ggad7b7f4459be059eae1a7d83a8e190c28a503f4e9dca6c8c12ea38f9e8c1be0126">kNo</a> = 0, 
<a class="el" href="group__MCFCLASS__CLASSES.html#ggad7b7f4459be059eae1a7d83a8e190c28ace5b3b5f2037b0d65d161b53b7c940fe">kYes</a>
 }</td></tr>
<tr class="memdesc:gad7b7f4459be059eae1a7d83a8e190c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible reoptimization status of the MCF solver.  <a href="group__MCFCLASS__CLASSES.html#gad7b7f4459be059eae1a7d83a8e190c28">More...</a><br /></td></tr>
<tr class="separator:gad7b7f4459be059eae1a7d83a8e190c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb1b139bac65f5f35bdadc7549a819de"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gadb1b139bac65f5f35bdadc7549a819de">MCFFlFrmt</a> { <a class="el" href="group__MCFCLASS__CLASSES.html#ggadb1b139bac65f5f35bdadc7549a819dea6e65d07cdd719be7d99902bb47920a37">kDimacs</a> = 0, 
<a class="el" href="group__MCFCLASS__CLASSES.html#ggadb1b139bac65f5f35bdadc7549a819deac27a029d7010490d53e1df36b39597e6">kQDimacs</a>, 
<a class="el" href="group__MCFCLASS__CLASSES.html#ggadb1b139bac65f5f35bdadc7549a819dea65125719fd6c68bc3904a45937fcfd85">kMPS</a>, 
<a class="el" href="group__MCFCLASS__CLASSES.html#ggadb1b139bac65f5f35bdadc7549a819dea7efb98d1b3dfca0f601d4df644b418a0">kFWMPS</a>
 }</td></tr>
<tr class="memdesc:gadb1b139bac65f5f35bdadc7549a819de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public enum describing the possible file formats in WriteMCF().  <a href="group__MCFCLASS__CLASSES.html#gadb1b139bac65f5f35bdadc7549a819de">More...</a><br /></td></tr>
<tr class="separator:gadb1b139bac65f5f35bdadc7549a819de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad53d6229d7ec28555a9c9c2fd9abf773"><td class="memItemLeft" align="right" valign="top"><a id="gad53d6229d7ec28555a9c9c2fd9abf773"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a></td></tr>
<tr class="memdesc:gad53d6229d7ec28555a9c9c2fd9abf773"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of a node or arc ( &gt;= 0 ) <br /></td></tr>
<tr class="separator:gad53d6229d7ec28555a9c9c2fd9abf773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3388eb329ff0551a0b86b6c67e33d8"><td class="memItemLeft" align="right" valign="top"><a id="gace3388eb329ff0551a0b86b6c67e33d8"></a>
typedef <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a></td></tr>
<tr class="memdesc:gace3388eb329ff0551a0b86b6c67e33d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set (array) of indices <br /></td></tr>
<tr class="separator:gace3388eb329ff0551a0b86b6c67e33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81575b2d4e4d5636b17170432150ae69"><td class="memItemLeft" align="right" valign="top"><a id="ga81575b2d4e4d5636b17170432150ae69"></a>
typedef <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a></td></tr>
<tr class="memdesc:ga81575b2d4e4d5636b17170432150ae69"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only index array <br /></td></tr>
<tr class="separator:ga81575b2d4e4d5636b17170432150ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeea3e5951d222b2a8e57de1b4246a909"><td class="memItemLeft" align="right" valign="top"><a id="gaeea3e5951d222b2a8e57de1b4246a909"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gaeea3e5951d222b2a8e57de1b4246a909">FNumber</a></td></tr>
<tr class="memdesc:gaeea3e5951d222b2a8e57de1b4246a909"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow <br /></td></tr>
<tr class="separator:gaeea3e5951d222b2a8e57de1b4246a909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="memItemLeft" align="right" valign="top"><a id="ga9dae1f1a39c208ce3c2b337cd5bb3d00"></a>
typedef <a class="el" href="group__MCFCLASS__CLASSES.html#gaeea3e5951d222b2a8e57de1b4246a909">FNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a></td></tr>
<tr class="memdesc:ga9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of flows <br /></td></tr>
<tr class="separator:ga9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad325f3193dbba0ddef1da4e72d29eda6"><td class="memItemLeft" align="right" valign="top"><a id="gad325f3193dbba0ddef1da4e72d29eda6"></a>
typedef <a class="el" href="group__MCFCLASS__CLASSES.html#ga6adcdfb385a23635365383fe22557e6f">cFNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a></td></tr>
<tr class="memdesc:gad325f3193dbba0ddef1da4e72d29eda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only flow array <br /></td></tr>
<tr class="separator:gad325f3193dbba0ddef1da4e72d29eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d0627ba8213afe1ec4ebeb4508e8f1"><td class="memItemLeft" align="right" valign="top"><a id="ga24d0627ba8213afe1ec4ebeb4508e8f1"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a></td></tr>
<tr class="memdesc:ga24d0627ba8213afe1ec4ebeb4508e8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow cost <br /></td></tr>
<tr class="separator:ga24d0627ba8213afe1ec4ebeb4508e8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62409402be4e4b301e1a568f99f877be"><td class="memItemLeft" align="right" valign="top"><a id="ga62409402be4e4b301e1a568f99f877be"></a>
typedef <a class="el" href="group__MCFCLASS__CLASSES.html#ga24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga62409402be4e4b301e1a568f99f877be">CRow</a></td></tr>
<tr class="memdesc:ga62409402be4e4b301e1a568f99f877be"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of costs <br /></td></tr>
<tr class="separator:ga62409402be4e4b301e1a568f99f877be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab700102e9ba8bb6015be6818d4e99097"><td class="memItemLeft" align="right" valign="top"><a id="gab700102e9ba8bb6015be6818d4e99097"></a>
typedef <a class="el" href="group__MCFCLASS__CLASSES.html#gadfca8fab5ee3441d967c2477e7334d9e">cCNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a></td></tr>
<tr class="memdesc:gab700102e9ba8bb6015be6818d4e99097"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only cost array <br /></td></tr>
<tr class="separator:gab700102e9ba8bb6015be6818d4e99097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ee7b3099b0bc780a6a4b43629488fa"><td class="memItemLeft" align="right" valign="top"><a id="gaf5ee7b3099b0bc780a6a4b43629488fa"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gaf5ee7b3099b0bc780a6a4b43629488fa">FONumber</a></td></tr>
<tr class="memdesc:gaf5ee7b3099b0bc780a6a4b43629488fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the objective function: has to hold sums of products of FNumber(s) by CNumber(s) <br /></td></tr>
<tr class="separator:gaf5ee7b3099b0bc780a6a4b43629488fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab547218814e3b90d15f219f5aaf8b937"><td class="memItemLeft" align="right" valign="top"><a id="gab547218814e3b90d15f219f5aaf8b937"></a>
typedef <a class="el" href="classMCFClass_1_1MCFState.html">MCFState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a></td></tr>
<tr class="memdesc:gab547218814e3b90d15f219f5aaf8b937"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to a <a class="el" href="classMCFClass_1_1MCFState.html" title="Base class for representing the internal state of the MCF algorithm.">MCFState</a> <br /></td></tr>
<tr class="separator:gab547218814e3b90d15f219f5aaf8b937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae709badc46f57b401841f5e3724eea41"><td class="memItemLeft" align="right" valign="top"><a id="gae709badc46f57b401841f5e3724eea41"></a>
const typedef <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a></td></tr>
<tr class="memdesc:gae709badc46f57b401841f5e3724eea41"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only index <br /></td></tr>
<tr class="separator:gae709badc46f57b401841f5e3724eea41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6adcdfb385a23635365383fe22557e6f"><td class="memItemLeft" align="right" valign="top"><a id="ga6adcdfb385a23635365383fe22557e6f"></a>
const typedef <a class="el" href="group__MCFCLASS__CLASSES.html#gaeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga6adcdfb385a23635365383fe22557e6f">cFNumber</a></td></tr>
<tr class="memdesc:ga6adcdfb385a23635365383fe22557e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only flow <br /></td></tr>
<tr class="separator:ga6adcdfb385a23635365383fe22557e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfca8fab5ee3441d967c2477e7334d9e"><td class="memItemLeft" align="right" valign="top"><a id="gadfca8fab5ee3441d967c2477e7334d9e"></a>
const typedef <a class="el" href="group__MCFCLASS__CLASSES.html#ga24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gadfca8fab5ee3441d967c2477e7334d9e">cCNumber</a></td></tr>
<tr class="memdesc:gadfca8fab5ee3441d967c2477e7334d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only cost <br /></td></tr>
<tr class="separator:gadfca8fab5ee3441d967c2477e7334d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2688d0f3f2c6218baef7b3411004a6a5"><td class="memItemLeft" align="right" valign="top"><a id="ga2688d0f3f2c6218baef7b3411004a6a5"></a>
const typedef <a class="el" href="group__MCFCLASS__CLASSES.html#gaf5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga2688d0f3f2c6218baef7b3411004a6a5">cFONumber</a></td></tr>
<tr class="memdesc:ga2688d0f3f2c6218baef7b3411004a6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only o.f. value <br /></td></tr>
<tr class="separator:ga2688d0f3f2c6218baef7b3411004a6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Other initializations</h2></td></tr>
<tr class="memitem:ga8d82d26f7845eb69081c860e14c3dc4c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c">LoadNet</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> nmx=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> mmx=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> pn=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> pm=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> pU=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a> pC=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> pDfct=0, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> pSn=0, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> pEn=0)=0</td></tr>
<tr class="memdesc:ga8d82d26f7845eb69081c860e14c3dc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs a new network.  <a href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c">More...</a><br /></td></tr>
<tr class="separator:ga8d82d26f7845eb69081c860e14c3dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d79a2f00cf8a2416b2b3e41552e843"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga34d79a2f00cf8a2416b2b3e41552e843">LoadDMX</a> (istream &amp;DMXs, bool IsQuad=false)</td></tr>
<tr class="memdesc:ga34d79a2f00cf8a2416b2b3e41552e843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a MCF instance in DIMACS standard format from the istream.  <a href="group__MCFCLASS__CLASSES.html#ga34d79a2f00cf8a2416b2b3e41552e843">More...</a><br /></td></tr>
<tr class="separator:ga34d79a2f00cf8a2416b2b3e41552e843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8e162715d8454f30679c10372db4db8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gab8e162715d8454f30679c10372db4db8">SetPar</a> (int par, int val)</td></tr>
<tr class="memdesc:gab8e162715d8454f30679c10372db4db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set integer parameters of the algorithm.  <a href="group__MCFCLASS__CLASSES.html#gab8e162715d8454f30679c10372db4db8">More...</a><br /></td></tr>
<tr class="separator:gab8e162715d8454f30679c10372db4db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4acd81f913880873c577de03a4fa1959"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga4acd81f913880873c577de03a4fa1959">SetPar</a> (int par, double val)</td></tr>
<tr class="memdesc:ga4acd81f913880873c577de03a4fa1959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set float parameters of the algorithm.  <a href="group__MCFCLASS__CLASSES.html#ga4acd81f913880873c577de03a4fa1959">More...</a><br /></td></tr>
<tr class="separator:ga4acd81f913880873c577de03a4fa1959"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Solving the problem</h2></td></tr>
<tr class="memitem:gac0d96429d896a2d878a5f057535ab1ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gac0d96429d896a2d878a5f057535ab1ee">SolveMCF</a> (void)=0</td></tr>
<tr class="memdesc:gac0d96429d896a2d878a5f057535ab1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver of the Min Cost Flow Problem.  <a href="group__MCFCLASS__CLASSES.html#gac0d96429d896a2d878a5f057535ab1ee">More...</a><br /></td></tr>
<tr class="separator:gac0d96429d896a2d878a5f057535ab1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reading flow solution</h2></td></tr>
<tr class="memitem:ga884f1180138ddf3df909347b1c85428c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga884f1180138ddf3df909347b1c85428c">MCFGetX</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#ga9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> F, <a class="el" href="group__MCFCLASS__CLASSES.html#gace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:ga884f1180138ddf3df909347b1c85428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the optimal flow solution in the vector F[].  <a href="group__MCFCLASS__CLASSES.html#ga884f1180138ddf3df909347b1c85428c">More...</a><br /></td></tr>
<tr class="separator:ga884f1180138ddf3df909347b1c85428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reading potentials</h2></td></tr>
<tr class="memitem:ga8c573c04800332c86ea31aeb80bbd7b1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga8c573c04800332c86ea31aeb80bbd7b1">MCFGetPi</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#ga62409402be4e4b301e1a568f99f877be">CRow</a> P, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:ga8c573c04800332c86ea31aeb80bbd7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the optimal node potentials in the vector P[].  <a href="group__MCFCLASS__CLASSES.html#ga8c573c04800332c86ea31aeb80bbd7b1">More...</a><br /></td></tr>
<tr class="separator:ga8c573c04800332c86ea31aeb80bbd7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reading reduced costs</h2></td></tr>
<tr class="memitem:ga361d84ae42041fdbf3824d45fc4c54aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga361d84ae42041fdbf3824d45fc4c54aa">MCFGetRC</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#ga62409402be4e4b301e1a568f99f877be">CRow</a> CR, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:ga361d84ae42041fdbf3824d45fc4c54aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the reduced costs corresponding to the current dual solution in RC[].  <a href="group__MCFCLASS__CLASSES.html#ga361d84ae42041fdbf3824d45fc4c54aa">More...</a><br /></td></tr>
<tr class="separator:ga361d84ae42041fdbf3824d45fc4c54aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c103b582c910ccfda354032aae5722e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#ga24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga7c103b582c910ccfda354032aae5722e">MCFGetRC</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> i)=0</td></tr>
<tr class="memdesc:ga7c103b582c910ccfda354032aae5722e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reduced cost of the i-th arc.  <a href="group__MCFCLASS__CLASSES.html#ga7c103b582c910ccfda354032aae5722e">More...</a><br /></td></tr>
<tr class="separator:ga7c103b582c910ccfda354032aae5722e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reading the objective function value</h2></td></tr>
<tr class="memitem:ga109d7c021feda837d8ca5051fc24b6ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gaf5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga109d7c021feda837d8ca5051fc24b6ea">MCFGetFO</a> (void)=0</td></tr>
<tr class="memdesc:ga109d7c021feda837d8ca5051fc24b6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the objective function value of the primal solution currently returned by <a class="el" href="group__MCFCLASS__CLASSES.html#ga884f1180138ddf3df909347b1c85428c" title="Write the optimal flow solution in the vector F[].">MCFGetX()</a>.  <a href="group__MCFCLASS__CLASSES.html#ga109d7c021feda837d8ca5051fc24b6ea">More...</a><br /></td></tr>
<tr class="separator:ga109d7c021feda837d8ca5051fc24b6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Check the solutions</h2></td></tr>
<tr class="memitem:ga41b70e84f98f30b408d0ffb191ff4442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga41b70e84f98f30b408d0ffb191ff4442">CheckPSol</a> (void)</td></tr>
<tr class="memdesc:ga41b70e84f98f30b408d0ffb191ff4442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the primal solution returned by the solver is primal feasible.  <a href="group__MCFCLASS__CLASSES.html#ga41b70e84f98f30b408d0ffb191ff4442">More...</a><br /></td></tr>
<tr class="separator:ga41b70e84f98f30b408d0ffb191ff4442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81bd6bc3b87534b4a67d0d93abedbd93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81bd6bc3b87534b4a67d0d93abedbd93">CheckDSol</a> (void)</td></tr>
<tr class="memdesc:ga81bd6bc3b87534b4a67d0d93abedbd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the dual solution returned by the solver is dual feasible.  <a href="group__MCFCLASS__CLASSES.html#ga81bd6bc3b87534b4a67d0d93abedbd93">More...</a><br /></td></tr>
<tr class="separator:ga81bd6bc3b87534b4a67d0d93abedbd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reading graph topology</h2></td></tr>
<tr class="memitem:gaa2314bf81483649dd1cb9dada0de6832"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gaa2314bf81483649dd1cb9dada0de6832">MCFArcs</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Startv, <a class="el" href="group__MCFCLASS__CLASSES.html#gace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Endv, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:gaa2314bf81483649dd1cb9dada0de6832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the starting (tail) and ending (head) nodes of the arcs in Startv[] and Endv[].  <a href="group__MCFCLASS__CLASSES.html#gaa2314bf81483649dd1cb9dada0de6832">More...</a><br /></td></tr>
<tr class="separator:gaa2314bf81483649dd1cb9dada0de6832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3f1b21bfe422e2d54de0dc56231599b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gae3f1b21bfe422e2d54de0dc56231599b">MCFSNde</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> i)=0</td></tr>
<tr class="memdesc:gae3f1b21bfe422e2d54de0dc56231599b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the starting (tail) node of the arc &lsquo;i&rsquo;.  <a href="group__MCFCLASS__CLASSES.html#gae3f1b21bfe422e2d54de0dc56231599b">More...</a><br /></td></tr>
<tr class="separator:gae3f1b21bfe422e2d54de0dc56231599b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0d5b8f2dfd729783e7c0fd604dc896"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga1b0d5b8f2dfd729783e7c0fd604dc896">MCFENde</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> i)=0</td></tr>
<tr class="memdesc:ga1b0d5b8f2dfd729783e7c0fd604dc896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ending (head) node of the arc &lsquo;i&rsquo;.  <a href="group__MCFCLASS__CLASSES.html#ga1b0d5b8f2dfd729783e7c0fd604dc896">More...</a><br /></td></tr>
<tr class="separator:ga1b0d5b8f2dfd729783e7c0fd604dc896"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reading arc costs</h2></td></tr>
<tr class="memitem:gab6dbac4cde9477589de653081986abb4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gab6dbac4cde9477589de653081986abb4">MCFCosts</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#ga62409402be4e4b301e1a568f99f877be">CRow</a> Costv, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:gab6dbac4cde9477589de653081986abb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the arc costs into Costv[].  <a href="group__MCFCLASS__CLASSES.html#gab6dbac4cde9477589de653081986abb4">More...</a><br /></td></tr>
<tr class="separator:gab6dbac4cde9477589de653081986abb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac666df7c1e7ed07c0f7574ec307c9e82"><td class="memItemLeft" align="right" valign="top"><a id="gac666df7c1e7ed07c0f7574ec307c9e82"></a>
virtual <a class="el" href="group__MCFCLASS__CLASSES.html#ga24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gac666df7c1e7ed07c0f7574ec307c9e82">MCFCost</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> i)=0</td></tr>
<tr class="memdesc:gac666df7c1e7ed07c0f7574ec307c9e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cost of the i-th arc. <br /></td></tr>
<tr class="separator:gac666df7c1e7ed07c0f7574ec307c9e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd08873d1e15db41bf42648226f8feb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gacd08873d1e15db41bf42648226f8feb1">MCFQCoef</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#ga62409402be4e4b301e1a568f99f877be">CRow</a> Qv, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:gacd08873d1e15db41bf42648226f8feb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9227949082669e0e9ca0c545406f1f4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#ga24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gab9227949082669e0e9ca0c545406f1f4">MCFQCoef</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> i)</td></tr>
<tr class="separator:gab9227949082669e0e9ca0c545406f1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reading arc capacities</h2></td></tr>
<tr class="memitem:ga999b9738aa5cb925c5b4a799ed6d4838"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga999b9738aa5cb925c5b4a799ed6d4838">MCFUCaps</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#ga9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> UCapv, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:ga999b9738aa5cb925c5b4a799ed6d4838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the arc capacities into UCapv[].  <a href="group__MCFCLASS__CLASSES.html#ga999b9738aa5cb925c5b4a799ed6d4838">More...</a><br /></td></tr>
<tr class="separator:ga999b9738aa5cb925c5b4a799ed6d4838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3af18f0859dd6ddea9d29ed39c9b27a3"><td class="memItemLeft" align="right" valign="top"><a id="ga3af18f0859dd6ddea9d29ed39c9b27a3"></a>
virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gaeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga3af18f0859dd6ddea9d29ed39c9b27a3">MCFUCap</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> i)=0</td></tr>
<tr class="memdesc:ga3af18f0859dd6ddea9d29ed39c9b27a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the capacity of the i-th arc. <br /></td></tr>
<tr class="separator:ga3af18f0859dd6ddea9d29ed39c9b27a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reading node deficits</h2></td></tr>
<tr class="memitem:ga99e2d376efc0d9552a62f9b71512b563"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga99e2d376efc0d9552a62f9b71512b563">MCFDfcts</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#ga9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> Dfctv, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:ga99e2d376efc0d9552a62f9b71512b563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the node deficits into Dfctv[].  <a href="group__MCFCLASS__CLASSES.html#ga99e2d376efc0d9552a62f9b71512b563">More...</a><br /></td></tr>
<tr class="separator:ga99e2d376efc0d9552a62f9b71512b563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e07cb46404db5a9fd83075a0908208"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gaeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81e07cb46404db5a9fd83075a0908208">MCFDfct</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> i)=0</td></tr>
<tr class="memdesc:ga81e07cb46404db5a9fd83075a0908208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the deficit of the i-th node.  <a href="group__MCFCLASS__CLASSES.html#ga81e07cb46404db5a9fd83075a0908208">More...</a><br /></td></tr>
<tr class="separator:ga81e07cb46404db5a9fd83075a0908208"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Write problem to file</h2></td></tr>
<tr class="memitem:gacd008d9548bf3e1aef1291864171bb2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gacd008d9548bf3e1aef1291864171bb2d">WriteMCF</a> (ostream &amp;oStrm, int frmt=0)</td></tr>
<tr class="memdesc:gacd008d9548bf3e1aef1291864171bb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the current MCF problem to an ostream.  <a href="group__MCFCLASS__CLASSES.html#gacd008d9548bf3e1aef1291864171bb2d">More...</a><br /></td></tr>
<tr class="separator:gacd008d9548bf3e1aef1291864171bb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Changing the costs</h2></td></tr>
<tr class="memitem:gaedaaa3c7820183c210ff8b1cc716c27d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gaedaaa3c7820183c210ff8b1cc716c27d">ChgCosts</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a> NCost, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:gaedaaa3c7820183c210ff8b1cc716c27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the arc costs.  <a href="group__MCFCLASS__CLASSES.html#gaedaaa3c7820183c210ff8b1cc716c27d">More...</a><br /></td></tr>
<tr class="separator:gaedaaa3c7820183c210ff8b1cc716c27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ab6d76a454b3f792665cce35a250f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga41ab6d76a454b3f792665cce35a250f3">ChgCost</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> arc, <a class="el" href="group__MCFCLASS__CLASSES.html#gadfca8fab5ee3441d967c2477e7334d9e">cCNumber</a> NCost)=0</td></tr>
<tr class="memdesc:ga41ab6d76a454b3f792665cce35a250f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the cost of the i-th arc.  <a href="group__MCFCLASS__CLASSES.html#ga41ab6d76a454b3f792665cce35a250f3">More...</a><br /></td></tr>
<tr class="separator:ga41ab6d76a454b3f792665cce35a250f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa1d49c3edafbf4783d579d175070fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga4aa1d49c3edafbf4783d579d175070fd">ChgQCoef</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a> NQCoef=0, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:ga4aa1d49c3edafbf4783d579d175070fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df44e18d436b2500e5608d6ab2d58ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga4df44e18d436b2500e5608d6ab2d58ad">ChgQCoef</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> arc, <a class="el" href="group__MCFCLASS__CLASSES.html#gadfca8fab5ee3441d967c2477e7334d9e">cCNumber</a> NQCoef)</td></tr>
<tr class="separator:ga4df44e18d436b2500e5608d6ab2d58ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Changing the capacities</h2></td></tr>
<tr class="memitem:gad548db90d9914f8a40bbb4823f274ccc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gad548db90d9914f8a40bbb4823f274ccc">ChgUCaps</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> NCap, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:gad548db90d9914f8a40bbb4823f274ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the arc capacities.  <a href="group__MCFCLASS__CLASSES.html#gad548db90d9914f8a40bbb4823f274ccc">More...</a><br /></td></tr>
<tr class="separator:gad548db90d9914f8a40bbb4823f274ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga832883594b6ea5a00fabc9f4be41d9e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga832883594b6ea5a00fabc9f4be41d9e5">ChgUCap</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> arc, <a class="el" href="group__MCFCLASS__CLASSES.html#ga6adcdfb385a23635365383fe22557e6f">cFNumber</a> NCap)=0</td></tr>
<tr class="memdesc:ga832883594b6ea5a00fabc9f4be41d9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the capacity of the i-th arc.  <a href="group__MCFCLASS__CLASSES.html#ga832883594b6ea5a00fabc9f4be41d9e5">More...</a><br /></td></tr>
<tr class="separator:ga832883594b6ea5a00fabc9f4be41d9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Changing the deficits</h2></td></tr>
<tr class="memitem:ga50ee5aaf0f8b39a1edec078828ade458"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga50ee5aaf0f8b39a1edec078828ade458">ChgDfcts</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> NDfct, <a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> strt=0, <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:ga50ee5aaf0f8b39a1edec078828ade458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the node deficits.  <a href="group__MCFCLASS__CLASSES.html#ga50ee5aaf0f8b39a1edec078828ade458">More...</a><br /></td></tr>
<tr class="separator:ga50ee5aaf0f8b39a1edec078828ade458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae235c4b587c8cffb777719c9221970"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga5ae235c4b587c8cffb777719c9221970">ChgDfct</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> node, <a class="el" href="group__MCFCLASS__CLASSES.html#ga6adcdfb385a23635365383fe22557e6f">cFNumber</a> NDfct)=0</td></tr>
<tr class="memdesc:ga5ae235c4b587c8cffb777719c9221970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the deficit of the i-th node.  <a href="group__MCFCLASS__CLASSES.html#ga5ae235c4b587c8cffb777719c9221970">More...</a><br /></td></tr>
<tr class="separator:ga5ae235c4b587c8cffb777719c9221970"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Changing graph topology</h2></td></tr>
<tr class="memitem:gae1c33ba491b57343fbc157123fff5b11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11">CloseArc</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> name)=0</td></tr>
<tr class="memdesc:gae1c33ba491b57343fbc157123fff5b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Close" the arc &lsquo;name&rsquo;.  <a href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11">More...</a><br /></td></tr>
<tr class="separator:gae1c33ba491b57343fbc157123fff5b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db08ae33bcdb997677a69f36c60c1e5"><td class="memItemLeft" align="right" valign="top"><a id="ga2db08ae33bcdb997677a69f36c60c1e5"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga2db08ae33bcdb997677a69f36c60c1e5">IsClosedArc</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> name)=0</td></tr>
<tr class="memdesc:ga2db08ae33bcdb997677a69f36c60c1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__MCFCLASS__CLASSES.html#ga2db08ae33bcdb997677a69f36c60c1e5" title="IsClosedArc() returns true if and only if the arc ‘name’ is closed.">IsClosedArc()</a> returns true if and only if the arc &lsquo;name&rsquo; is closed. <br /></td></tr>
<tr class="separator:ga2db08ae33bcdb997677a69f36c60c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabecb8b32d512eea7daafba0e06ab4742"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gabecb8b32d512eea7daafba0e06ab4742">DelNode</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> name)=0</td></tr>
<tr class="memdesc:gabecb8b32d512eea7daafba0e06ab4742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the node &lsquo;name&rsquo;.  <a href="group__MCFCLASS__CLASSES.html#gabecb8b32d512eea7daafba0e06ab4742">More...</a><br /></td></tr>
<tr class="separator:gabecb8b32d512eea7daafba0e06ab4742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab902a23d1c9520a22b79de5d451c3348"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gab902a23d1c9520a22b79de5d451c3348">OpenArc</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> name)=0</td></tr>
<tr class="memdesc:gab902a23d1c9520a22b79de5d451c3348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the previously closed arc &lsquo;name&rsquo;.  <a href="group__MCFCLASS__CLASSES.html#gab902a23d1c9520a22b79de5d451c3348">More...</a><br /></td></tr>
<tr class="separator:gab902a23d1c9520a22b79de5d451c3348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d58679267d8b620cc3337583dab4626"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga6d58679267d8b620cc3337583dab4626">AddNode</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#ga6adcdfb385a23635365383fe22557e6f">cFNumber</a> aDfct)=0</td></tr>
<tr class="memdesc:ga6d58679267d8b620cc3337583dab4626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new node with deficit aDfct, returning its name.  <a href="group__MCFCLASS__CLASSES.html#ga6d58679267d8b620cc3337583dab4626">More...</a><br /></td></tr>
<tr class="separator:ga6d58679267d8b620cc3337583dab4626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2d28b0b0a2420d6b8b7093d827fa67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gaef2d28b0b0a2420d6b8b7093d827fa67">ChangeArc</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> name, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> nSN=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;(), <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> nEN=<a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt; <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:gaef2d28b0b0a2420d6b8b7093d827fa67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the starting and/or ending node of arc &lsquo;name&rsquo; to nSN and nEN.  <a href="group__MCFCLASS__CLASSES.html#gaef2d28b0b0a2420d6b8b7093d827fa67">More...</a><br /></td></tr>
<tr class="separator:gaef2d28b0b0a2420d6b8b7093d827fa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae291d6625ff31a5fdcc1ef166e2dee34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gae291d6625ff31a5fdcc1ef166e2dee34">DelArc</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> name)=0</td></tr>
<tr class="memdesc:gae291d6625ff31a5fdcc1ef166e2dee34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the arc &lsquo;name&rsquo;.  <a href="group__MCFCLASS__CLASSES.html#gae291d6625ff31a5fdcc1ef166e2dee34">More...</a><br /></td></tr>
<tr class="separator:gae291d6625ff31a5fdcc1ef166e2dee34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f72b1b728182519a6a11accdfa78c7d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga5f72b1b728182519a6a11accdfa78c7d">IsDeletedArc</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> name)=0</td></tr>
<tr class="memdesc:ga5f72b1b728182519a6a11accdfa78c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if and only if the arc &lsquo;name&rsquo; is deleted.  <a href="group__MCFCLASS__CLASSES.html#ga5f72b1b728182519a6a11accdfa78c7d">More...</a><br /></td></tr>
<tr class="separator:ga5f72b1b728182519a6a11accdfa78c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga564d624f62ccc0c130d733cc5470cb6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga564d624f62ccc0c130d733cc5470cb6d">AddArc</a> (<a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> Start, <a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a> End, <a class="el" href="group__MCFCLASS__CLASSES.html#ga6adcdfb385a23635365383fe22557e6f">cFNumber</a> aU, <a class="el" href="group__MCFCLASS__CLASSES.html#gadfca8fab5ee3441d967c2477e7334d9e">cCNumber</a> aC)=0</td></tr>
<tr class="memdesc:ga564d624f62ccc0c130d733cc5470cb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the new arc ( Start , End ) with cost aC and capacity aU, returning its name.  <a href="group__MCFCLASS__CLASSES.html#ga564d624f62ccc0c130d733cc5470cb6d">More...</a><br /></td></tr>
<tr class="separator:ga564d624f62ccc0c130d733cc5470cb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Managing comparisons.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp9aa9bd89f944889c8c3183c847b3e49b"></a>The following methods are provided for making it easier to perform comparisons, with and without tolerances. </p>
</td></tr>
<tr class="memitem:ga7f0f8bcc88c30609d766a4e723a53dac"><td class="memItemLeft" align="right" valign="top"><a id="ga7f0f8bcc88c30609d766a4e723a53dac"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga7f0f8bcc88c30609d766a4e723a53dac">n</a></td></tr>
<tr class="memdesc:ga7f0f8bcc88c30609d766a4e723a53dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of nodes <br /></td></tr>
<tr class="separator:ga7f0f8bcc88c30609d766a4e723a53dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02366e13d56b1124db9bf8281b73ca9a"><td class="memItemLeft" align="right" valign="top"><a id="ga02366e13d56b1124db9bf8281b73ca9a"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga02366e13d56b1124db9bf8281b73ca9a">nmax</a></td></tr>
<tr class="memdesc:ga02366e13d56b1124db9bf8281b73ca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of nodes <br /></td></tr>
<tr class="separator:ga02366e13d56b1124db9bf8281b73ca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d50257929003fb000e6bcc1db02fd6"><td class="memItemLeft" align="right" valign="top"><a id="ga61d50257929003fb000e6bcc1db02fd6"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga61d50257929003fb000e6bcc1db02fd6">m</a></td></tr>
<tr class="memdesc:ga61d50257929003fb000e6bcc1db02fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of arcs <br /></td></tr>
<tr class="separator:ga61d50257929003fb000e6bcc1db02fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e7022437bc38dc11cffe32d4b2332c"><td class="memItemLeft" align="right" valign="top"><a id="ga93e7022437bc38dc11cffe32d4b2332c"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga93e7022437bc38dc11cffe32d4b2332c">mmax</a></td></tr>
<tr class="memdesc:ga93e7022437bc38dc11cffe32d4b2332c"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of arcs <br /></td></tr>
<tr class="separator:ga93e7022437bc38dc11cffe32d4b2332c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e27f49150e9a14580fb313cc2777e00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga6e27f49150e9a14580fb313cc2777e00">status</a></td></tr>
<tr class="memdesc:ga6e27f49150e9a14580fb313cc2777e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">return status, see the comments to MCFGetStatus() above.  <a href="group__MCFCLASS__CLASSES.html#ga6e27f49150e9a14580fb313cc2777e00">More...</a><br /></td></tr>
<tr class="separator:ga6e27f49150e9a14580fb313cc2777e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b691e0b125c33ab526888ab754e461"><td class="memItemLeft" align="right" valign="top"><a id="ga89b691e0b125c33ab526888ab754e461"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga89b691e0b125c33ab526888ab754e461">Senstv</a></td></tr>
<tr class="memdesc:ga89b691e0b125c33ab526888ab754e461"><td class="mdescLeft">&#160;</td><td class="mdescRight">true &lt;=&gt; the latest optimal solution should be exploited <br /></td></tr>
<tr class="separator:ga89b691e0b125c33ab526888ab754e461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7624a057d988dd8f61b038ff459cd0b"><td class="memItemLeft" align="right" valign="top"><a id="gab7624a057d988dd8f61b038ff459cd0b"></a>
<a class="el" href="classOPTtypes__di__unipi__it_1_1OPTtimers.html">OPTtimers</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gab7624a057d988dd8f61b038ff459cd0b">MCFt</a></td></tr>
<tr class="memdesc:gab7624a057d988dd8f61b038ff459cd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">timer for performances evaluation <br /></td></tr>
<tr class="separator:gab7624a057d988dd8f61b038ff459cd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b1c456efbc2e544b82cb6553f6df8d"><td class="memItemLeft" align="right" valign="top"><a id="ga65b1c456efbc2e544b82cb6553f6df8d"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#gaeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga65b1c456efbc2e544b82cb6553f6df8d">EpsFlw</a></td></tr>
<tr class="memdesc:ga65b1c456efbc2e544b82cb6553f6df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing arc flows / capacities <br /></td></tr>
<tr class="separator:ga65b1c456efbc2e544b82cb6553f6df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9159ee7ca50477fd57f6854ff73b2874"><td class="memItemLeft" align="right" valign="top"><a id="ga9159ee7ca50477fd57f6854ff73b2874"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#gaeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga9159ee7ca50477fd57f6854ff73b2874">EpsDfct</a></td></tr>
<tr class="memdesc:ga9159ee7ca50477fd57f6854ff73b2874"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing node deficits <br /></td></tr>
<tr class="separator:ga9159ee7ca50477fd57f6854ff73b2874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad8c11b8ba9065dd3bc0f7b5ec423869"><td class="memItemLeft" align="right" valign="top"><a id="gaad8c11b8ba9065dd3bc0f7b5ec423869"></a>
<a class="el" href="group__MCFCLASS__CLASSES.html#ga24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gaad8c11b8ba9065dd3bc0f7b5ec423869">EpsCst</a></td></tr>
<tr class="memdesc:gaad8c11b8ba9065dd3bc0f7b5ec423869"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing arc costs <br /></td></tr>
<tr class="separator:gaad8c11b8ba9065dd3bc0f7b5ec423869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bad127f3e412819d99baff0c51e5be8"><td class="memItemLeft" align="right" valign="top"><a id="ga8bad127f3e412819d99baff0c51e5be8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga8bad127f3e412819d99baff0c51e5be8">MaxTime</a></td></tr>
<tr class="memdesc:ga8bad127f3e412819d99baff0c51e5be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">max time (in seconds) in which MCF Solver can find an optimal solution (0 = no limits) <br /></td></tr>
<tr class="separator:ga8bad127f3e412819d99baff0c51e5be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga259eaddd4d91ec0a7d00ff6db0a3f40a"><td class="memItemLeft" align="right" valign="top"><a id="ga259eaddd4d91ec0a7d00ff6db0a3f40a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga259eaddd4d91ec0a7d00ff6db0a3f40a">MaxIter</a></td></tr>
<tr class="memdesc:ga259eaddd4d91ec0a7d00ff6db0a3f40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">max number of iterations in which MCF Solver can find an optimal solution (0 = no limits) <br /></td></tr>
<tr class="separator:ga259eaddd4d91ec0a7d00ff6db0a3f40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadaea79b7a516a86d9e318c31ce3d489"><td class="memTemplParams" colspan="2"><a id="gaadaea79b7a516a86d9e318c31ce3d489"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gaadaea79b7a516a86d9e318c31ce3d489"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gaadaea79b7a516a86d9e318c31ce3d489">ETZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:gaadaea79b7a516a86d9e318c31ce3d489"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is equal to zero (possibly considering tolerances). <br /></td></tr>
<tr class="separator:gaadaea79b7a516a86d9e318c31ce3d489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf314a8df7e38143854b9bf17c8eb25fc"><td class="memTemplParams" colspan="2"><a id="gaf314a8df7e38143854b9bf17c8eb25fc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf314a8df7e38143854b9bf17c8eb25fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gaf314a8df7e38143854b9bf17c8eb25fc">GTZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:gaf314a8df7e38143854b9bf17c8eb25fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than zero (possibly considering tolerances). <br /></td></tr>
<tr class="separator:gaf314a8df7e38143854b9bf17c8eb25fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae414baaa6f224ce576574baa1e71650a"><td class="memTemplParams" colspan="2"><a id="gae414baaa6f224ce576574baa1e71650a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gae414baaa6f224ce576574baa1e71650a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gae414baaa6f224ce576574baa1e71650a">GEZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:gae414baaa6f224ce576574baa1e71650a"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than or equal to zero (possibly considering tolerances). <br /></td></tr>
<tr class="separator:gae414baaa6f224ce576574baa1e71650a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab355a057db64a4b3da5209f747c01eae"><td class="memTemplParams" colspan="2"><a id="gab355a057db64a4b3da5209f747c01eae"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gab355a057db64a4b3da5209f747c01eae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gab355a057db64a4b3da5209f747c01eae">LTZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:gab355a057db64a4b3da5209f747c01eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than zero (possibly considering tolerances). <br /></td></tr>
<tr class="separator:gab355a057db64a4b3da5209f747c01eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc1dfab25fba0d9badd0cce4dc99933b"><td class="memTemplParams" colspan="2"><a id="gadc1dfab25fba0d9badd0cce4dc99933b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gadc1dfab25fba0d9badd0cce4dc99933b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#gadc1dfab25fba0d9badd0cce4dc99933b">LEZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:gadc1dfab25fba0d9badd0cce4dc99933b"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than or equal to zero (possibly considering tolerances). <br /></td></tr>
<tr class="separator:gadc1dfab25fba0d9badd0cce4dc99933b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga945c3a54be501ad68f71adaf7771d457"><td class="memTemplParams" colspan="2"><a id="ga945c3a54be501ad68f71adaf7771d457"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga945c3a54be501ad68f71adaf7771d457"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga945c3a54be501ad68f71adaf7771d457">GT</a> (T x, T y, const T eps)</td></tr>
<tr class="memdesc:ga945c3a54be501ad68f71adaf7771d457"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than flow y (possibly considering tolerances). <br /></td></tr>
<tr class="separator:ga945c3a54be501ad68f71adaf7771d457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0374fafa5efdfe1d78c22efaa9f9d6"><td class="memTemplParams" colspan="2"><a id="ga7c0374fafa5efdfe1d78c22efaa9f9d6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7c0374fafa5efdfe1d78c22efaa9f9d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MCFCLASS__CLASSES.html#ga7c0374fafa5efdfe1d78c22efaa9f9d6">LT</a> (T x, T y, const T eps)</td></tr>
<tr class="memdesc:ga7c0374fafa5efdfe1d78c22efaa9f9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than flow y (possibly considering tolerances). <br /></td></tr>
<tr class="separator:ga7c0374fafa5efdfe1d78c22efaa9f9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf6e60cb841150361862d6b895c523e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6e60cb841150361862d6b895c523e0a">&#9670;&nbsp;</a></span>MCFParam</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MCFCLASS__CLASSES.html#gaf6e60cb841150361862d6b895c523e0a">MCFParam</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible parameters of the MCF solver, to be used with the methods <a class="el" href="group__MCFCLASS__CLASSES.html#gab8e162715d8454f30679c10372db4db8" title="Set integer parameters of the algorithm.">SetPar()</a> and GetPar(). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf6e60cb841150361862d6b895c523e0aab35d3e473676b56fa123d6df3d855aa0"></a>kMaxTime&#160;</td><td class="fielddoc"><p>max time </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6e60cb841150361862d6b895c523e0aa50d3edcd55bc1dd84d4e1719430f9d20"></a>kMaxIter&#160;</td><td class="fielddoc"><p>max number of iteration </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6e60cb841150361862d6b895c523e0aa753a94f6a06a5579eb0855479dfbb6b1"></a>kEpsFlw&#160;</td><td class="fielddoc"><p>tolerance for flows </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6e60cb841150361862d6b895c523e0aa409d9ed5655d184667a5e486e5110c6e"></a>kEpsDfct&#160;</td><td class="fielddoc"><p>tolerance for deficits </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6e60cb841150361862d6b895c523e0aaf263085cb23be60527c92896891cd12c"></a>kEpsCst&#160;</td><td class="fielddoc"><p>tolerance for costs </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6e60cb841150361862d6b895c523e0aa7efdbe01bec821f08a391f9542086475"></a>kReopt&#160;</td><td class="fielddoc"><p>whether or not to reoptimize </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6e60cb841150361862d6b895c523e0aa99ac8339170db67bf9af4a60362ef7e1"></a>kLastParam&#160;</td><td class="fielddoc"><p>dummy parameter: this is used to allow derived classes to "extend" the set of parameters. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga15ef269c5dd98eea5274eb03a3feb5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15ef269c5dd98eea5274eb03a3feb5fb">&#9670;&nbsp;</a></span>MCFStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MCFCLASS__CLASSES.html#ga15ef269c5dd98eea5274eb03a3feb5fb">MCFStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible status of the MCF solver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1"></a>kUnSolved&#160;</td><td class="fielddoc"><p>no solution available </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15ef269c5dd98eea5274eb03a3feb5fba42e6b26684acf67af002df88a9cf997c"></a>kOK&#160;</td><td class="fielddoc"><p>optimal solution found </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15ef269c5dd98eea5274eb03a3feb5fba142714524ffdfe9cfebaa1033fd1a18f"></a>kStopped&#160;</td><td class="fielddoc"><p>optimization stopped </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15ef269c5dd98eea5274eb03a3feb5fba7db95dc60f32bc33a35f748f639cc6d0"></a>kUnfeasible&#160;</td><td class="fielddoc"><p>problem is unfeasible </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15ef269c5dd98eea5274eb03a3feb5fba4b9de95ee3087851acd98262e09f0be8"></a>kUnbounded&#160;</td><td class="fielddoc"><p>problem is unbounded </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15ef269c5dd98eea5274eb03a3feb5fbaacb2c04376333850bff6fb1065c0c171"></a>kError&#160;</td><td class="fielddoc"><p>error in the solver </p>
</td></tr>
</table>

</div>
</div>
<a id="gad7b7f4459be059eae1a7d83a8e190c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b7f4459be059eae1a7d83a8e190c28">&#9670;&nbsp;</a></span>MCFAnswer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MCFCLASS__CLASSES.html#gad7b7f4459be059eae1a7d83a8e190c28">MCFAnswer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible reoptimization status of the MCF solver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad7b7f4459be059eae1a7d83a8e190c28a503f4e9dca6c8c12ea38f9e8c1be0126"></a>kNo&#160;</td><td class="fielddoc"><p>no </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b7f4459be059eae1a7d83a8e190c28ace5b3b5f2037b0d65d161b53b7c940fe"></a>kYes&#160;</td><td class="fielddoc"><p>yes </p>
</td></tr>
</table>

</div>
</div>
<a id="gadb1b139bac65f5f35bdadc7549a819de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb1b139bac65f5f35bdadc7549a819de">&#9670;&nbsp;</a></span>MCFFlFrmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MCFCLASS__CLASSES.html#gadb1b139bac65f5f35bdadc7549a819de">MCFFlFrmt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible file formats in <a class="el" href="group__MCFCLASS__CLASSES.html#gacd008d9548bf3e1aef1291864171bb2d" title="Write the current MCF problem to an ostream.">WriteMCF()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadb1b139bac65f5f35bdadc7549a819dea6e65d07cdd719be7d99902bb47920a37"></a>kDimacs&#160;</td><td class="fielddoc"><p>DIMACS file format for MCF. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadb1b139bac65f5f35bdadc7549a819deac27a029d7010490d53e1df36b39597e6"></a>kQDimacs&#160;</td><td class="fielddoc"><p>quadratic DIMACS file format for MCF </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadb1b139bac65f5f35bdadc7549a819dea65125719fd6c68bc3904a45937fcfd85"></a>kMPS&#160;</td><td class="fielddoc"><p>MPS file format for LP. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadb1b139bac65f5f35bdadc7549a819dea7efb98d1b3dfca0f601d4df644b418a0"></a>kFWMPS&#160;</td><td class="fielddoc"><p>"Fixed Width" MPS format </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8d82d26f7845eb69081c860e14c3dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d82d26f7845eb69081c860e14c3dc4c">&#9670;&nbsp;</a></span>LoadNet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LoadNet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>mmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>pn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>pm</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>pU</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>pC</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>pDfct</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>pSn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>pEn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inputs a new network. </p>
<p>The parameters nmx and mmx are the new max number of nodes and arcs, possibly overriding those set in the constructor [see above], altough at the likely cost of memory allocation and deallocation. Passing nmx == mmx == 0 is intended as a signal to the solver to deallocate everything and wait for new orders; in this case, all the other parameters are ignored.</p>
<p>Otherwise, in principle all the other parameters have to be provided. Actually, some of them may not be needed for special classes of MCF problems (e.g., costs in a MaxFlow problem, or start/end nodes in a problem defined over a graph with fixed topology, such as a complete graph). Also, passing 0 is allowed to set default values.</p>
<p>The meaning of the parameters is the following:</p>
<ul>
<li>pn is the current number of nodes of the network (&lt;= nmax).</li>
<li>pm is the number of arcs of the network (&lt;= mmax).</li>
<li>pU is the m-vector of the arc upper capacities; capacities must be nonnegative, but can in principle be infinite (== F_INF); passing pU == 0 means that all capacities are infinite;</li>
<li>pC is the m-vector of the arc costs; costs must be finite (&lt; C_INF); passing pC == 0 means that all costs must be 0.</li>
<li>pDfct is the n-vector of the node deficits; source nodes have negative deficits and sink nodes have positive deficits; passing pDfct == 0 means that all deficits must be 0 (a circulation problem);</li>
<li>pSn is the m-vector of the arc starting nodes; pSn == 0 is in principle not allowed, unless the topology of the graph is fixed;</li>
<li>pEn is the m-vector of the arc ending nodes; same comments as for pSn.</li>
</ul>
<p>Note that node "names" in the arrays pSn and pEn must go from 1 to pn if the macro USANAME0 [see above] is set to 0, while they must go from 0 to pn - 1 if USANAME0 is set to 1. In both cases, however, the deficit of the first node is read from the first (0-th) position of pDfct, that is if USANAME0 == 0 then the deficit of the node with name &lsquo;i&rsquo; is read from pDfct[ i - 1 ].</p>
<p>The data passed to <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">LoadNet()</a> can be used to specify that the arc &lsquo;i&rsquo; must not "exist" in the problem. This is done by passing pC[ i ] == C_INF; solvers which don't read costs are forced to read them in order to check this, unless they provide alternative solver-specific ways to accomplish the same tasks. These arcs are "closed", as for the effect of <a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc ‘name’.">CloseArc()</a> [see below]. "invalid" costs (== C_INF) are set to 0 in order to being subsequently capable of "opening" them back with <a class="el" href="group__MCFCLASS__CLASSES.html#gab902a23d1c9520a22b79de5d451c3348" title="Restore the previously closed arc ‘name’.">OpenArc()</a> [see below]. The way in which these non-existent arcs are phisically dealt with is solver-specific; in some solvers, for instance, this could be obtained by simply putting their capacity to zero. Details about these issues should be found in the interface of derived classes.</p>
<p>Note that the quadratic part of the objective function, if any, is not dealt with in <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">LoadNet()</a>; it can only be separately provided with <a class="el" href="group__MCFCLASS__CLASSES.html#ga4aa1d49c3edafbf4783d579d175070fd">ChgQCoef()</a> [see below]. By default, the problem is linear, i.e., all coefficients of the second-order terms in the objective function are assumed to be zero. </p>

<p>Implemented in <a class="el" href="group__RELAXIV__CLASSES.html#gac270d18d58fd6fe88164cde1f4c80aff">RelaxIV</a>, <a class="el" href="group__MCFCPLEX__CLASSES.html#gac270d18d58fd6fe88164cde1f4c80aff">MCFCplex</a>, <a class="el" href="group__MCFZIB__CLASSES.html#gac270d18d58fd6fe88164cde1f4c80aff">MCFZIB</a>, <a class="el" href="group__MCFSimplex__CLASSES.html#gac270d18d58fd6fe88164cde1f4c80aff">MCFSimplex</a>, and <a class="el" href="group__SPTREE__CLASSES.html#gafbfa5c036f9ea67e35005ec77b82214a">SPTree</a>.</p>

</div>
</div>
<a id="ga34d79a2f00cf8a2416b2b3e41552e843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34d79a2f00cf8a2416b2b3e41552e843">&#9670;&nbsp;</a></span>LoadDMX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoadDMX </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>DMXs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IsQuad</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a MCF instance in DIMACS standard format from the istream. </p>
<p>The format is the following. The first line must be</p>
<p>p min &lt;number of nodes&gt; &lt;number of arcs&gt;</p>
<p>Then the node definition lines must be found, in the form</p>
<p>n &lt;node number&gt; &lt;node supply&gt;</p>
<p>Not all nodes need have a node definition line; these are given zero supply, i.e., they are transhipment nodes (supplies are the inverse of deficits, i.e., a node with positive supply is a source node). Finally, the arc definition lines must be found, in the form</p>
<p>a &lt;start node&gt; &lt;end node&gt; &lt;lower bound&gt; &lt;upper bound&gt; &lt;flow cost&gt;</p>
<p>There must be exactly &lt;number of arcs&gt; arc definition lines in the file.</p>
<p>This method is <em>not</em> pure virtual because an implementation is provided by the base class, using the <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">LoadNet()</a> method (which <em>is</em> pure virtual). However, the method <em>is</em> virtual to allow derived classes to implement more efficient versions, should they have any reason to do so.</p>
<dl class="section note"><dt>Note</dt><dd>Actually, the file format accepted by LoadDMX (at least in the base class implementation) is more general than the DIMACS standard format, in that it is allowed to mix node and arc definitions in any order, while the DIMACS file requires all node information to appear before all arc information.</dd>
<dd>
Other than for the above, this method is assumed to allow for quadratic* Dimacs files, encoding for convex quadratic separable Min Cost Flow instances. This is a simple extension where each arc descriptor has a sixth field, &lt;quadratic cost&gt;. The provided istream is assumed to be quadratic Dimacs file if IsQuad is true, and a regular linear Dimacs file otherwise. </dd></dl>

</div>
</div>
<a id="gab8e162715d8454f30679c10372db4db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8e162715d8454f30679c10372db4db8">&#9670;&nbsp;</a></span>SetPar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set integer parameters of the algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>is the parameter to be set; the enum MCFParam can be used, but 'par' is an int (every enum is an int) so that the method can be extended by derived classes for the setting of their parameters</td></tr>
    <tr><td class="paramname">value</td><td>is the value to assign to the parameter. <br  />
</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles these parameters:</p>
<ul>
<li>kMaxIter: the max number of iterations in which the MCF Solver can find an optimal solution (default 0, which means no limit)</li>
<li>kReopt: tells the solver if it has to reoptimize. The implementation in the base class sets a flag, the protected <code>bool</code> field <code>Senstv</code>; if true (default) this field instructs the MCF solver to to try to exploit the information about the latest optimal solution to speedup the optimization of the current problem, while if the field is false the MCF solver should restart the optimization "from scratch" discarding any previous information. Usually reoptimization speeds up the computation considerably, but this is not always true, especially if the data of the problem changes a lot. </li>
</ul>

<p>Reimplemented in <a class="el" href="group__RELAXIV__CLASSES.html#gaebda2a23b313bb3ab143e66137ada924">RelaxIV</a>, <a class="el" href="group__MCFCPLEX__CLASSES.html#ga12105bbd99b8b7ad7efae3bb0c222b3c">MCFCplex</a>, and <a class="el" href="group__MCFSimplex__CLASSES.html#gaebda2a23b313bb3ab143e66137ada924">MCFSimplex</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__MCFCPLEX__CLASSES.html#ga12105bbd99b8b7ad7efae3bb0c222b3c">MCFCplex::SetPar()</a>, and <a class="el" href="group__RELAXIV__CLASSES.html#gaebda2a23b313bb3ab143e66137ada924">RelaxIV::SetPar()</a>.</p>

</div>
</div>
<a id="ga4acd81f913880873c577de03a4fa1959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4acd81f913880873c577de03a4fa1959">&#9670;&nbsp;</a></span>SetPar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set float parameters of the algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>is the parameter to be set; the enum MCFParam can be used, but 'par' is an int (every enum is an int) so that the method can be extended by derived classes for the setting of their parameters</td></tr>
    <tr><td class="paramname">value</td><td>is the value to assign to the parameter. <br  />
</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles these parameters:</p>
<ul>
<li>kEpsFlw: sets the tolerance for controlling if the flow on an arc is zero to val. This also sets the tolerance for controlling if a node deficit is zero (see kEpsDfct) to val * &lt; max number of nodes &gt;; this value should be safe for graphs in which any node has less than &lt; max number of nodes &gt; adjacent nodes, i.e., for all graphs but for very dense ones with "parallel arcs"</li>
<li>kEpsDfct: sets the tolerance for controlling if a node deficit is zero to val, in case a better value than that autmatically set by kEpsFlw (see above) is available (e.g., val * k would be good if no node has more than k neighbours)</li>
<li>kEpsCst: sets the tolerance for controlling if the reduced cost of an arc is zero to val. A feasible solution satisfying eps-complementary slackness, i.e., such that <p class="formulaDsp">
\[ RC[ i , j ] &lt; - eps \Rightarrow X[ i , j ] = U[ ij ] \]
</p>
 and <p class="formulaDsp">
\[ RC[ i , j ] &gt; eps \Rightarrow X[ i , j ] == 0 , \]
</p>
 is known to be ( eps * n )-optimal.</li>
<li>kMaxTime: sets the max time (in seconds) in which the MCF Solver can find an optimal solution (default 0, which means no limit). </li>
</ul>

<p>Reimplemented in <a class="el" href="group__RELAXIV__CLASSES.html#gae6eb12cc8e2e124b236bf84ebeddab70">RelaxIV</a>, <a class="el" href="group__MCFCPLEX__CLASSES.html#ga64a55cf140fd8543ab0cf88cc052d8d7">MCFCplex</a>, and <a class="el" href="group__MCFSimplex__CLASSES.html#gae6eb12cc8e2e124b236bf84ebeddab70">MCFSimplex</a>.</p>

</div>
</div>
<a id="gac0d96429d896a2d878a5f057535ab1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0d96429d896a2d878a5f057535ab1ee">&#9670;&nbsp;</a></span>SolveMCF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SolveMCF </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solver of the Min Cost Flow Problem. </p>
<p>Attempts to solve the MCF instance currently loaded in the object. </p>

</div>
</div>
<a id="ga884f1180138ddf3df909347b1c85428c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga884f1180138ddf3df909347b1c85428c">&#9670;&nbsp;</a></span>MCFGetX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFGetX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the optimal flow solution in the vector F[]. </p>
<p>If nms == 0, F[] will be in "dense" format, i.e., the flow relative to arc &lsquo;i&rsquo; (i in 0 .. m - 1) is written in F[ i ]. If nms != 0, F[] will be in "sparse" format, i.e., the indices of the nonzero elements in the flow solution are written in nms (that is then Inf&lt;Index&gt;()-terminated) and the flow value of arc nms[ i ] is written in F[ i ]. Note that nms is not* guaranteed to be ordered. Also, note that, unlike <a class="el" href="group__MCFCLASS__CLASSES.html#ga361d84ae42041fdbf3824d45fc4c54aa" title="Write the reduced costs corresponding to the current dual solution in RC[].">MCFGetRC()</a> and <a class="el" href="group__MCFCLASS__CLASSES.html#ga8c573c04800332c86ea31aeb80bbd7b1" title="Writes the optimal node potentials in the vector P[].">MCFGetPi()</a> [see below], nms is an <em>output</em> of the method.</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). </p>

</div>
</div>
<a id="ga8c573c04800332c86ea31aeb80bbd7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c573c04800332c86ea31aeb80bbd7b1">&#9670;&nbsp;</a></span>MCFGetPi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFGetPi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the optimal node potentials in the vector P[]. </p>
<p>If nms == 0, the node potential of node &lsquo;i&rsquo; (i in 0 .. n - 1) is written in P[ i ] (note that here node names always start from zero, regardless to the value of USENAME0). If nms != 0, it must point to a vector of indices in 0 .. n - 1 (ordered in increasing sense and Inf&lt;Index&gt;()-terminated), and the node potential of nms[ i ] is written in P[ i ]. Note that, unlike <a class="el" href="group__MCFCLASS__CLASSES.html#ga884f1180138ddf3df909347b1c85428c" title="Write the optimal flow solution in the vector F[].">MCFGetX()</a> above, nms is an <em>input</em> of the method.</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the nodes &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFn() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to nodes which are <em>both</em> in nms[] and whose index is in the correct range are returned. </p>

<p>Implemented in <a class="el" href="group__RELAXIV__CLASSES.html#gabb97afaf7df33019f1b728138a254d6d">RelaxIV</a>.</p>

</div>
</div>
<a id="ga361d84ae42041fdbf3824d45fc4c54aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga361d84ae42041fdbf3824d45fc4c54aa">&#9670;&nbsp;</a></span>MCFGetRC() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFGetRC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>CR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the reduced costs corresponding to the current dual solution in RC[]. </p>
<p>If nms == 0, the reduced cost of arc &lsquo;i&rsquo; (i in 0 .. m - 1) is written in RC[ i ]; if nms != 0, it must point to a vector of indices in 0 .. m - 1 (ordered in increasing sense and Inf&lt;Index&gt;()-terminated), and the reduced cost of arc nms[ i ] is written in RC[ i ]. Note that, unlike <a class="el" href="group__MCFCLASS__CLASSES.html#ga884f1180138ddf3df909347b1c85428c" title="Write the optimal flow solution in the vector F[].">MCFGetX()</a> above, nms is an <em>input</em> of the method.</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms[] and whose index is in the correct range are returned.</p>
<dl class="section note"><dt>Note</dt><dd>the output of <a class="el" href="group__MCFCLASS__CLASSES.html#ga361d84ae42041fdbf3824d45fc4c54aa" title="Write the reduced costs corresponding to the current dual solution in RC[].">MCFGetRC()</a> will change after any call to HaveNewPi() [see above] which returns true. </dd></dl>

</div>
</div>
<a id="ga7c103b582c910ccfda354032aae5722e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c103b582c910ccfda354032aae5722e">&#9670;&nbsp;</a></span>MCFGetRC() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#ga24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> MCFGetRC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the reduced cost of the i-th arc. </p>
<p>This information should be cheapily available in most implementations.</p>
<dl class="section note"><dt>Note</dt><dd>the output of <a class="el" href="group__MCFCLASS__CLASSES.html#ga361d84ae42041fdbf3824d45fc4c54aa" title="Write the reduced costs corresponding to the current dual solution in RC[].">MCFGetRC()</a> will change after any call to HaveNewPi() [see above] which returns true. </dd></dl>

</div>
</div>
<a id="ga109d7c021feda837d8ca5051fc24b6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga109d7c021feda837d8ca5051fc24b6ea">&#9670;&nbsp;</a></span>MCFGetFO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gaf5ee7b3099b0bc780a6a4b43629488fa">FONumber</a> MCFGetFO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the objective function value of the primal solution currently returned by <a class="el" href="group__MCFCLASS__CLASSES.html#ga884f1180138ddf3df909347b1c85428c" title="Write the optimal flow solution in the vector F[].">MCFGetX()</a>. </p>
<p>If MCFGetStatus() == kOK, this is guaranteed to be the optimal objective function value of the problem (to within the optimality tolerances), but only prior to any call to HaveNewX() that returns true. <a class="el" href="group__MCFCLASS__CLASSES.html#ga109d7c021feda837d8ca5051fc24b6ea" title="Return the objective function value of the primal solution currently returned by MCFGetX().">MCFGetFO()</a> typically returns Inf&lt;FONumber&gt;() if MCFGetStatus() == kUnfeasible and</p><ul>
<li>Inf&lt;FONumber&gt;() if MCFGetStatus() == kUnbounded. If MCFGetStatus() == kStopped and <a class="el" href="group__MCFCLASS__CLASSES.html#ga109d7c021feda837d8ca5051fc24b6ea" title="Return the objective function value of the primal solution currently returned by MCFGetX().">MCFGetFO()</a> returns a finite value, it must be an upper bound on the optimal objective function value (typically, the objective function value of one primal feasible solution). </li>
</ul>

<p>Implemented in <a class="el" href="group__SPTREE__CLASSES.html#ga55b9b095d557852a91b68c973236518a">SPTree</a>.</p>

</div>
</div>
<a id="ga41b70e84f98f30b408d0ffb191ff4442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41b70e84f98f30b408d0ffb191ff4442">&#9670;&nbsp;</a></span>CheckPSol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CheckPSol </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the primal solution returned by the solver is primal feasible. </p>
<p>(to within the tolerances set by SetPar(kEps****) [see above], if any). Also, check that the objective function value is correct.</p>
<p>This method is implemented by the base class, using the above methods for collecting the solutions and the methods of the next section for reading the data of the problem; as such, they will work for any derived class that properly implements all these methods. </p>

</div>
</div>
<a id="ga81bd6bc3b87534b4a67d0d93abedbd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81bd6bc3b87534b4a67d0d93abedbd93">&#9670;&nbsp;</a></span>CheckDSol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CheckDSol </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the dual solution returned by the solver is dual feasible. </p>
<p>(to within the tolerances set by SetPar(kEps****) [see above], if any). Also, check that the objective function value is correct.</p>
<p>This method is implemented by the base class, using the above methods for collecting the solutions and the methods of the next section for reading the data of the problem; as such, they will work for any derived class that properly implements all these methods. </p>

</div>
</div>
<a id="gaa2314bf81483649dd1cb9dada0de6832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2314bf81483649dd1cb9dada0de6832">&#9670;&nbsp;</a></span>MCFArcs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFArcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Startv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Endv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the starting (tail) and ending (head) nodes of the arcs in Startv[] and Endv[]. </p>
<p>If nms == 0, then the information relative to all arcs is written into Startv[] and Endv[], otherwise Startv[ i ] and Endv[ i ] contain the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned.</p>
<p>Startv or Endv can be 0, meaning that only the other information is required.</p>
<dl class="section note"><dt>Note</dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1.</dd>
<dd>
If the graph is "dynamic", be careful to use MCFn() e MCFm() to properly choose the dimension of nodes and arcs arrays. </dd></dl>

</div>
</div>
<a id="gae3f1b21bfe422e2d54de0dc56231599b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3f1b21bfe422e2d54de0dc56231599b">&#9670;&nbsp;</a></span>MCFSNde()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFSNde </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the starting (tail) node of the arc &lsquo;i&rsquo;. </p>
<dl class="section note"><dt>Note</dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1. </dd></dl>

</div>
</div>
<a id="ga1b0d5b8f2dfd729783e7c0fd604dc896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b0d5b8f2dfd729783e7c0fd604dc896">&#9670;&nbsp;</a></span>MCFENde()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MCFENde </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ending (head) node of the arc &lsquo;i&rsquo;. </p>
<dl class="section note"><dt>Note</dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1. </dd></dl>

</div>
</div>
<a id="gab6dbac4cde9477589de653081986abb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6dbac4cde9477589de653081986abb4">&#9670;&nbsp;</a></span>MCFCosts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFCosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>Costv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the arc costs into Costv[]. </p>
<p>If nms == 0, then all the costs are written, otherwise Costv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned. </p>

</div>
</div>
<a id="gacd08873d1e15db41bf42648226f8feb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd08873d1e15db41bf42648226f8feb1">&#9670;&nbsp;</a></span>MCFQCoef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>Qv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stp</td><td>Write the quadratic coefficients of the arc costs into Qv[]. If nms == 0, then all the costs are written, otherwise Costv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</td></tr>
  </table>
  </dd>
</dl>
<p>The parameters `strt' and `stp' allow to restrict the output of the method to all and only the arcs `i' with strt &lt;= i &lt; min( MCFm() , stp ). `strt' and `stp' work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are *both* in nms and whose index is in the correct range are returned.</p>
<p>Note that the method is *not* pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients. </p>

</div>
</div>
<a id="gab9227949082669e0e9ca0c545406f1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9227949082669e0e9ca0c545406f1f4">&#9670;&nbsp;</a></span>MCFQCoef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#ga24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> MCFQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Return the quadratic coefficients of the cost of the i-th arc. Note that the method is *not* pure virtual: an implementation is provided for "pure
   linear" MCF solvers that only work with all zero quadratic coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga999b9738aa5cb925c5b4a799ed6d4838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga999b9738aa5cb925c5b4a799ed6d4838">&#9670;&nbsp;</a></span>MCFUCaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFUCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>UCapv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the arc capacities into UCapv[]. </p>
<p>If nms == 0, then all the capacities are written, otherwise UCapv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the arcs &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFm() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to arcs which are <em>both</em> in nms and whose index is in the correct range are returned. </p>

</div>
</div>
<a id="ga99e2d376efc0d9552a62f9b71512b563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99e2d376efc0d9552a62f9b71512b563">&#9670;&nbsp;</a></span>MCFDfcts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFDfcts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>Dfctv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the node deficits into Dfctv[]. </p>
<p>If nms == 0, then all the defcits are written, otherwise Dfctvv[ i ] contains the information relative to node nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters &lsquo;strt&rsquo; and &lsquo;stp&rsquo; allow to restrict the output of the method to all and only the nodes &lsquo;i&rsquo; with strt &lt;= i &lt; min( MCFn() , stp ). &lsquo;strt&rsquo; and &lsquo;stp&rsquo; work in "&amp;&amp;" with nms; that is, if nms != 0 then only the values corresponding to nodes which are <em>both</em> in nms and whose index is in the correct range are returned.</p>
<dl class="section note"><dt>Note</dt><dd>Here node "names" (strt and stp, those contained in nms[] or &lsquo;i&rsquo; in <a class="el" href="group__MCFCLASS__CLASSES.html#ga81e07cb46404db5a9fd83075a0908208" title="Return the deficit of the i-th node.">MCFDfct()</a>) go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is returned by MCFDfcts( Dfctv , 0 , 0 , 1 ). </dd></dl>

</div>
</div>
<a id="ga81e07cb46404db5a9fd83075a0908208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81e07cb46404db5a9fd83075a0908208">&#9670;&nbsp;</a></span>MCFDfct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gaeea3e5951d222b2a8e57de1b4246a909">FNumber</a> MCFDfct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the deficit of the i-th node. </p>
<dl class="section note"><dt>Note</dt><dd>Here node "names" go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is returned by MCFDfct( 0 ). </dd></dl>

</div>
</div>
<a id="gacd008d9548bf3e1aef1291864171bb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd008d9548bf3e1aef1291864171bb2d">&#9670;&nbsp;</a></span>WriteMCF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WriteMCF </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>oStrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frmt</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the current MCF problem to an ostream. </p>
<p>This may be useful e.g. for debugging purposes.</p>
<p>The base <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a> class provides output in two different formats, depending on the value of the parameter frmt:</p>
<ul>
<li>kDimacs the problem is written in DIMACS standard format, read by most MCF codes available;</li>
<li>kMPS the problem is written in the "modern version" (tab-separated) of the MPS format, read by most LP/MIP solvers;<ul>
<li>kFWMPS the problem is written in the "old version" (fixed width fields) of the MPS format; this is read by most LP/MIP solvers, but some codes still require the old format.</li>
</ul>
</li>
</ul>
<p>The implementation of <a class="el" href="group__MCFCLASS__CLASSES.html#gacd008d9548bf3e1aef1291864171bb2d" title="Write the current MCF problem to an ostream.">WriteMCF()</a> in the base class uses all the above methods for reading the data; as such it will work for any derived class that properly implements this part of the interface, but it may not be very efficient. Thus, the method is virtual to allow the derived classes to either re-implement <a class="el" href="group__MCFCLASS__CLASSES.html#gacd008d9548bf3e1aef1291864171bb2d" title="Write the current MCF problem to an ostream.">WriteMCF()</a> for the above two formats in a more efficient way, and/or to extend it to support other solver-specific formats.</p>
<dl class="section note"><dt>Note</dt><dd>None of the above two formats supports quadratic MCFs, so if nonzero quadratic coefficients are present, they are just ignored. </dd></dl>

<p>Reimplemented in <a class="el" href="group__RELAXIV__CLASSES.html#gae1d1711d5cdab205d15363b40a6686ee">RelaxIV</a>.</p>

<p class="reference">References <a class="el" href="group__MCFCLASS__MACROS.html#ga74cc96ffa32533b7eff040b5ffee5e06">USENAME0</a>.</p>

</div>
</div>
<a id="gaedaaa3c7820183c210ff8b1cc716c27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedaaa3c7820183c210ff8b1cc716c27d">&#9670;&nbsp;</a></span>ChgCosts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgCosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>NCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the arc costs. </p>
<p>In particular, change the costs that are:</p>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th cost will be changed to NCost[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; MCFm(), then the smaller bound is used.</p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs which have not been closed/deleted [see <a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc ‘name’.">CloseArc()</a> / <a class="el" href="group__MCFCLASS__CLASSES.html#gae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc ‘name’.">DelArc()</a> below and <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="ga41ab6d76a454b3f792665cce35a250f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ab6d76a454b3f792665cce35a250f3">&#9670;&nbsp;</a></span>ChgCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gadfca8fab5ee3441d967c2477e7334d9e">cCNumber</a>&#160;</td>
          <td class="paramname"><em>NCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the cost of the i-th arc. </p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs which have not been closed/deleted [see <a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc ‘name’.">CloseArc()</a> / <a class="el" href="group__MCFCLASS__CLASSES.html#gae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc ‘name’.">DelArc()</a> below and <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="ga4aa1d49c3edafbf4783d579d175070fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aa1d49c3edafbf4783d579d175070fd">&#9670;&nbsp;</a></span>ChgQCoef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>NQCoef</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stp</td><td>Change the quadratic coefficients of the arc costs. In particular, change the coefficients that are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>listed in into the vector of indices `nms' (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
<li>*and* whose name belongs to the interval [`strt', `stp').</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th cost will be changed to NCost[ i ]. If nms == 0 (as the default), *all* the entries in the given range will be changed; if stp &gt; MCFm(), then the smaller bound is used. If NQCoef == 0, all the specified coefficients are set to zero.</p>
<p>Note that the method is *not* pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients.</p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that *do not exist* is *not allowed*; only arcs which have not been closed/deleted [see <a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc ‘name’.">CloseArc()</a> / <a class="el" href="group__MCFCLASS__CLASSES.html#gae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc ‘name’.">DelArc()</a> below and <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="ga4df44e18d436b2500e5608d6ab2d58ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df44e18d436b2500e5608d6ab2d58ad">&#9670;&nbsp;</a></span>ChgQCoef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gadfca8fab5ee3441d967c2477e7334d9e">cCNumber</a>&#160;</td>
          <td class="paramname"><em>NQCoef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NQCoef</td><td>Change the quadratic coefficient of the cost of the i-th arc.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the method is *not* pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients.</p>
<dl class="section note"><dt>Note</dt><dd>changing the costs of arcs that *do not exist* is *not allowed*; only arcs which have not been closed/deleted [see <a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc ‘name’.">CloseArc()</a> / <a class="el" href="group__MCFCLASS__CLASSES.html#gae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc ‘name’.">DelArc()</a> below and <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="gad548db90d9914f8a40bbb4823f274ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad548db90d9914f8a40bbb4823f274ccc">&#9670;&nbsp;</a></span>ChgUCaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgUCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>NCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the arc capacities. </p>
<p>In particular, change the capacities that are:</p>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th capacity will be changed to NCap[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; MCFm(), then the smaller bound is used.</p>
<dl class="section note"><dt>Note</dt><dd>changing the capacities of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs that have not been closed/deleted [see <a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc ‘name’.">CloseArc()</a> / <a class="el" href="group__MCFCLASS__CLASSES.html#gae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc ‘name’.">DelArc()</a> below and <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="ga832883594b6ea5a00fabc9f4be41d9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga832883594b6ea5a00fabc9f4be41d9e5">&#9670;&nbsp;</a></span>ChgUCap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgUCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga6adcdfb385a23635365383fe22557e6f">cFNumber</a>&#160;</td>
          <td class="paramname"><em>NCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the capacity of the i-th arc. </p>
<dl class="section note"><dt>Note</dt><dd>changing the capacities of arcs that <em>do not exist</em> is <em>not allowed</em>; only arcs that have not been closed/deleted [see <a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc ‘name’.">CloseArc()</a> / <a class="el" href="group__MCFCLASS__CLASSES.html#gae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc ‘name’.">DelArc()</a> below and <a class="el" href="group__MCFCLASS__CLASSES.html#ga8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network.">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="ga50ee5aaf0f8b39a1edec078828ade458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50ee5aaf0f8b39a1edec078828ade458">&#9670;&nbsp;</a></span>ChgDfcts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgDfcts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>NDfct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the node deficits. </p>
<p>In particular, change the deficits that are:</p>
<ul>
<li>listed in into the vector of indices &lsquo;nms&rsquo; (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
<li><em>and</em> whose name belongs to the interval [&lsquo;strt&rsquo;, &lsquo;stp&rsquo;).</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th deficit will be changed to NDfct[ i ]. If nms == 0 (as the default), <em>all</em> the entries in the given range will be changed; if stp &gt; MCFn(), then the smaller bound is used.</p>
<p>Note that, in <a class="el" href="group__MCFCLASS__CLASSES.html#ga50ee5aaf0f8b39a1edec078828ade458" title="Change the node deficits.">ChgDfcts()</a>, node "names" (strt, stp or those contained in nms[]) go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit can be changed e.g. with ChgDfcts( &amp;new_deficit , 0 , 0 , 1 ).</p>
<dl class="section note"><dt>Note</dt><dd>changing the deficits of nodes that <em>do not exist</em> is <em>not allowed</em>; only nodes that have not been deleted [see <a class="el" href="group__MCFCLASS__CLASSES.html#gabecb8b32d512eea7daafba0e06ab4742" title="Delete the node ‘name’.">DelNode()</a> below] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="ga5ae235c4b587c8cffb777719c9221970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ae235c4b587c8cffb777719c9221970">&#9670;&nbsp;</a></span>ChgDfct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgDfct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga6adcdfb385a23635365383fe22557e6f">cFNumber</a>&#160;</td>
          <td class="paramname"><em>NDfct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the deficit of the i-th node. </p>
<p>Note that the node "name" i go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit can be changed e.g. with ChgDfcts( 0 , new_deficit ).</p>
<dl class="section note"><dt>Note</dt><dd>changing the deficits of nodes that <em>do not exist</em> is <em>not allowed</em>; only nodes that have not been deleted [see <a class="el" href="group__MCFCLASS__CLASSES.html#gabecb8b32d512eea7daafba0e06ab4742" title="Delete the node ‘name’.">DelNode()</a> below] can be touched with these methods. </dd></dl>

</div>
</div>
<a id="gae1c33ba491b57343fbc157123fff5b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1c33ba491b57343fbc157123fff5b11">&#9670;&nbsp;</a></span>CloseArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CloseArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Close" the arc &lsquo;name&rsquo;. </p>
<p>Although all the associated information (name, cost, capacity, end and start node) is kept, the arc is removed from the problem until OpenArc( i ) [see below] is called.</p>
<p>"closed" arcs always have 0 flow, but are otherwise counted as any other arc; for instance, MCFm() does <em>not</em> decrease as an effect of a call to <a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc ‘name’.">CloseArc()</a>. How this closure is implemented is solver-specific. </p>

</div>
</div>
<a id="gabecb8b32d512eea7daafba0e06ab4742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabecb8b32d512eea7daafba0e06ab4742">&#9670;&nbsp;</a></span>DelNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DelNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the node &lsquo;name&rsquo;. </p>
<p>For any value of &lsquo;name&rsquo;, all incident arcs to that node are closed [see <a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc ‘name’.">CloseArc()</a> above] (<em>not</em> Deleted, see <a class="el" href="group__MCFCLASS__CLASSES.html#gae291d6625ff31a5fdcc1ef166e2dee34" title="Delete the arc ‘name’.">DelArc()</a> below) and the deficit is set to zero.</p>
<p>Il furthermore &lsquo;name&rsquo; is the last node, the number of nodes as reported by MCFn() is reduced by at least one, until the n-th node is not a deleted one. </p>

</div>
</div>
<a id="gab902a23d1c9520a22b79de5d451c3348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab902a23d1c9520a22b79de5d451c3348">&#9670;&nbsp;</a></span>OpenArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OpenArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the previously closed arc &lsquo;name&rsquo;. </p>
<p>It is an error to open an arc that has not been previously closed. </p>

</div>
</div>
<a id="ga6d58679267d8b620cc3337583dab4626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d58679267d8b620cc3337583dab4626">&#9670;&nbsp;</a></span>AddNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> AddNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga6adcdfb385a23635365383fe22557e6f">cFNumber</a>&#160;</td>
          <td class="paramname"><em>aDfct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new node with deficit aDfct, returning its name. </p>
<p>Inf&lt;Index&gt;() is returned if there is no room for a new node. Remember that the node names are either { 0 .. nmax - 1 } or { 1 .. nmax }, depending on the value of USENAME0. </p>

</div>
</div>
<a id="gaef2d28b0b0a2420d6b8b7093d827fa67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef2d28b0b0a2420d6b8b7093d827fa67">&#9670;&nbsp;</a></span>ChangeArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChangeArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>nSN</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>nEN</em> = <code><a class="el" href="classOPTtypes__di__unipi__it_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the starting and/or ending node of arc &lsquo;name&rsquo; to nSN and nEN. </p>
<p>Each parameter being Inf&lt;Index&gt;() means to leave the previous starting or ending node untouched. When this method is called &lsquo;name&rsquo; can be either the name of a "normal" arc or that of a "closed" arc [see <a class="el" href="group__MCFCLASS__CLASSES.html#gae1c33ba491b57343fbc157123fff5b11" title="&quot;Close&quot; the arc ‘name’.">CloseArc()</a> above]: in the latter case, at the end of <a class="el" href="group__MCFCLASS__CLASSES.html#gaef2d28b0b0a2420d6b8b7093d827fa67" title="Change the starting and/or ending node of arc ‘name’ to nSN and nEN.">ChangeArc()</a> the arc is <em>still closed</em>, and it remains so until OpenArc( name ) [see above] is called. </p>

</div>
</div>
<a id="gae291d6625ff31a5fdcc1ef166e2dee34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae291d6625ff31a5fdcc1ef166e2dee34">&#9670;&nbsp;</a></span>DelArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DelArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the arc &lsquo;name&rsquo;. </p>
<p>Unlike "closed" arcs, all the information associated with a deleted arc is lost and &lsquo;name&rsquo; is made available as a name for new arcs to be created with <a class="el" href="group__MCFCLASS__CLASSES.html#ga564d624f62ccc0c130d733cc5470cb6d" title="Add the new arc ( Start , End ) with cost aC and capacity aU, returning its name.">AddArc()</a> [see below].</p>
<p>Il furthermore &lsquo;name&rsquo; is the last arc, the number of arcs as reported by MCFm() is reduced by at least one, until the m-th arc is not a deleted one. Otherwise, the flow on the arc is always ensured to be 0. </p>

</div>
</div>
<a id="ga5f72b1b728182519a6a11accdfa78c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f72b1b728182519a6a11accdfa78c7d">&#9670;&nbsp;</a></span>IsDeletedArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsDeletedArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if and only if the arc &lsquo;name&rsquo; is deleted. </p>
<p>It should only be called with name &lt; MCFm(), as every other arc is deleted by definition. </p>

</div>
</div>
<a id="ga564d624f62ccc0c130d733cc5470cb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga564d624f62ccc0c130d733cc5470cb6d">&#9670;&nbsp;</a></span>AddArc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__MCFCLASS__CLASSES.html#gad53d6229d7ec28555a9c9c2fd9abf773">Index</a> AddArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gae709badc46f57b401841f5e3724eea41">cIndex</a>&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#ga6adcdfb385a23635365383fe22557e6f">cFNumber</a>&#160;</td>
          <td class="paramname"><em>aU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MCFCLASS__CLASSES.html#gadfca8fab5ee3441d967c2477e7334d9e">cCNumber</a>&#160;</td>
          <td class="paramname"><em>aC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the new arc ( Start , End ) with cost aC and capacity aU, returning its name. </p>
<p>Inf&lt;Index&gt;() is returned if there is no room for a new arc. Remember that arc names go from 0 to mmax - 1. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga6e27f49150e9a14580fb313cc2777e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e27f49150e9a14580fb313cc2777e00">&#9670;&nbsp;</a></span>status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int status</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return status, see the comments to MCFGetStatus() above. </p>
<p>Note that the variable is defined int to allow derived classes to return their own specialized status codes </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
